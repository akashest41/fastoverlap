!    FASTOVERLAP
!    Copyright (C) 2017  Matthew Griffiths
!    
!    This program is free software; you can redistribute it and/or modify
!    it under the terms of the GNU General Public License as published by
!    the Free Software Foundation; either version 2 of the License, or
!    (at your option) any later version.
!    
!    This program is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU General Public License for more details.
!    
!    You should have received a copy of the GNU General Public License along
!    with this program; if not, write to the Free Software Foundation, Inc.,
!    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.



MODULE FASTOVERLAPUTILS

!***********************************************************************
! This module contains some subroutines that are useful for FASTOVERLAP 
! alignment for both periodic and isolated structures
!***********************************************************************
! Subroutines:
!     Peakfinding subroutines:
!         SETINDEXES
!         SETFSPACE
!         GAUSSIAN
!         FCN
!         FIT
!         FINDPEAK
!         FINDPEAKS
!     FFT subroutines
!         FFT3D
!         IFFT3D
!         FFT1D
!         IFFT1D
!***********************************************************************

IMPLICIT NONE

! Variables and arrays needed for peakfinding
INTEGER, PARAMETER :: N=11, DEFAULTWIDTH=2
DOUBLE PRECISION, PARAMETER :: DEFAULTTOL=1.D-6
INTEGER, SAVE :: FSIZE, FSHAPE(3)
DOUBLE PRECISION, SAVE, ALLOCATABLE :: FSPACE(:,:,:), FVEC(:), FJAC(:,:)

! An array of the fastest length arrays on which to perform FFTs
INTEGER*8, SAVE :: FASTLEN(200) = (/1, 2, 3, 4, 5, 6, 8, 8, 9, 10, 12, 12, 15, &
    15, 15, 16, 18, 18, 20, 20, 24, 24, 24, 24, 25, 27, 27, 30, 30, 30, 32, &
    32, 36, 36, 36, 36, 40, 40, 40, 40, 45, 45, 45, 45, 45, 48, 48, 48, 50, &
    50, 54, 54, 54, 54, 60, 60, 60, 60, 60, 60, 64, 64, 64, 64, 72, 72, 72, &
    72, 72, 72, 72, 72, 75, 75, 75, 80, 80, 80, 80, 80, 81, 90, 90, 90, 90, &
    90, 90, 90, 90, 90, 96, 96, 96, 96, 96, 96, 100, 100, 100, 100, 108, 108, &
    108, 108, 108, 108, 108, 108, 120, 120, 120, 120, 120, 120, 120, 120, 120,&
    120, 120, 120, 125, 125, 125, 125, 125, 128, 128, 128, 135, 135, 135, 135,&
    135, 135, 135, 144, 144, 144, 144, 144, 144, 144, 144, 144, 150, 150, 150,&
    150, 150, 150, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 162, 162,&
    180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180,&
    180, 180, 180, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192,&
    200, 200, 200, 200, 200, 200, 200, 200/)

CONTAINS

SUBROUTINE SETINDEXES(NEWSHAPE)

! Helper routine to allocate memory to appropriate arrays needed to perform
! Levenberg-Marquardt non-linear least-squares curve fitting to find peaks

IMPLICIT NONE

INTEGER, INTENT(IN) :: NEWSHAPE(3)

IF (.NOT.ALL(FSHAPE.EQ.NEWSHAPE)) THEN
    FSHAPE = NEWSHAPE    
    IF(ALLOCATED(FSPACE)) THEN
        DEALLOCATE(FSPACE)
    ENDIF
    IF(ALLOCATED(FVEC)) THEN
        DEALLOCATE(FVEC)
    ENDIF
    IF(ALLOCATED(FJAC)) THEN
        DEALLOCATE(FJAC)
    ENDIF
    
    ALLOCATE( FSPACE( FSHAPE(1),FSHAPE(2),FSHAPE(3) ) )
    FSIZE = SIZE(FSPACE)
    
    ALLOCATE(FVEC(FSIZE))
    ALLOCATE(FJAC(N,FSIZE))
ENDIF

END SUBROUTINE SETINDEXES

!***********************************************************************

SUBROUTINE SETFSPACE(NEWFSPACE)

IMPLICIT NONE

!INTEGER, INTENT(IN) :: NX,NY,NZ
DOUBLE PRECISION, INTENT(IN), DIMENSION(:,:,:) :: NEWFSPACE
!INTEGER NSHAPE(3)

!NSHAPE=(/NX,NY,NZ/)
CALL SETINDEXES(SHAPE(NEWFSPACE))

FSPACE = NEWFSPACE

END SUBROUTINE SETFSPACE

!***********************************************************************

SUBROUTINE GAUSSIAN(X,NX,NY,NZ,FOUT)

! Routine to calculate the values of a 3-D gaussian
! FOUT(IX, IY, IZ) = A * Exp(-(I-I0)^T SIGMA (I-I0))
! I = (/IX, IY, IZ/)
!specified by the parameter vector X:
! X = (\A, mean, SIGMA(1,1), SIGMA(2,2), SIGMA(3,3), SIGMA(1,2),SIGMA(2,3),SIGMA(1,3), I0(1), I0(2), I0(3) \)

IMPLICIT NONE

INTEGER*8, INTENT(IN) :: NX, NY, NZ
DOUBLE PRECISION, INTENT(IN), DIMENSION(:) :: X
DOUBLE PRECISION, INTENT(OUT) :: FOUT(NX,NY,NZ)

INTEGER*8 IX,IY,IZ,J
DOUBLE PRECISION SIGMA(3,3), A, MEAN, Y, EXPY, FY, IND0(3), DY(3)

A = X(1)
MEAN = X(2)
SIGMA(1,1) = X(3)
SIGMA(2,2) = X(4)
SIGMA(3,3) = X(5)
SIGMA(1,2) = X(6)
SIGMA(2,1) = 0.D0!X(6)
SIGMA(2,3) = X(7)
SIGMA(3,2) = 0.D0!X(7)
SIGMA(1,3) = X(8)
SIGMA(3,1) = 0.D0!X(8)
!IND0 = X(9:11)

DO IZ=1,NZ
    DO IY=1,NY
        DO IX=1,NX
            IND0 = (/IX,IY,IZ/) - X(9:11)
            DO J=1,3
                DY(J) = SUM(SIGMA(J,:)*IND0)
            ENDDO
            Y = SUM(IND0*DY)
            EXPY = EXP(-Y)
            FOUT(IX,IY,IZ) =  (A*EXPY + MEAN)
        ENDDO
    ENDDO
ENDDO

END SUBROUTINE GAUSSIAN

!***********************************************************************

SUBROUTINE FCN(M,N,X,FVEC,FJAC,LDFJAC,IFLAG)

! 
! subroutine passed to lmder1 to perform least squares regression, minimizing
! SUM((FOUT - FSPACE)**2)
! where  FOUT(IX, IY, IZ) = A * Exp(-(I-I0)^T SIGMA (I-I0))
! I = (/IX, IY, IZ/)
!specified by the parameter vector X:
! X = (\A, mean, SIGMA(1,1), SIGMA(2,2), SIGMA(3,3), SIGMA(1,2),SIGMA(2,3),SIGMA(1,3), I0(1), I0(2), I0(3) \)
! M = SIZE(FSPACE) is the number of observations
! LDFJAC = N specifies the dimension of the jacobian matrix
! N = 11 is the number of parameters to optimise
! If IFLAG=1 then calculates FVEC, the vector of square difference of each observation
! If IFLAG=2 then calculates FVEC and FJAC, the jacobian maxtrix of FVEC

IMPLICIT NONE

INTEGER*8, INTENT(IN) :: LDFJAC, N, M, IFLAG
DOUBLE PRECISION, INTENT(OUT) :: FJAC(LDFJAC, N), FVEC(M)
DOUBLE PRECISION, INTENT(INOUT) :: X(N)

DOUBLE PRECISION SIGMA(3,3), A, MEAN, Y, EXPY, FY, DIFF, DY(3), IND0(3)
INTEGER*8 :: I,J,K,IND(3)!,IX,IY,IZ!,S(2)=(/3,1/)

! if IFLAG =/= 1/2 then do nothing...
IF(IFLAG.EQ.1 .OR. IFLAG.EQ.2) THEN
A = X(1)
MEAN = X(2)
SIGMA(1,1) = X(3)
SIGMA(2,2) = X(4)
SIGMA(3,3) = X(5)
SIGMA(1,2) = X(6)
SIGMA(2,1) = 0.D0!X(6)
SIGMA(2,3) = X(7)
SIGMA(3,2) = 0.D0!X(7)
SIGMA(1,3) = X(8)
SIGMA(3,1) = 0.D0!X(8)
!IND0 = X(9:11)

DO I=1,M
    !Some pointer arithmetic to get the 3D index location
    !I miss 0-indexing
    IND(1) = (I-1)/FSHAPE(2)/FSHAPE(3) + 1
    IND(2) = MOD((I-1)/FSHAPE(3), FSHAPE(2)) + 1
    IND(3) = MOD(I-1, FSHAPE(3)) + 1
    IND0 = IND - X(9:11)
    !Y = 0.D0
    DO J=1,3
        DY(J) = SUM(SIGMA(J,:)*IND0)
    ENDDO
    Y = SUM(IND0*DY)
    EXPY = EXP(-Y)
    FY = (A*EXPY + MEAN)
    DIFF = (FY - FSPACE(IND(1),IND(2),IND(3)))
    FVEC(I) = DIFF**2
    IF(IFLAG.EQ.2) THEN
        ! Calculating Jacobian
        FJAC(I,1) = 2 * EXPY * DIFF
        FJAC(I,2) = 2 * DIFF
        FJAC(I,3) = -(IND0(1)*IND0(1))*A*EXPY * DIFF * 2
        FJAC(I,4) = -(IND0(2)*IND0(2))*A*EXPY * DIFF * 2
        FJAC(I,5) = -(IND0(3)*IND0(3))*A*EXPY * DIFF * 2
        FJAC(I,6) = -(IND0(1)*IND0(2))*A*EXPY * DIFF * 2
        FJAC(I,7) = -(IND0(2)*IND0(3))*A*EXPY * DIFF * 2
        FJAC(I,8) = -(IND0(1)*IND0(3))*A*EXPY * DIFF * 2
        FJAC(I,9:11) = 4 * DY * A * EXPY * DIFF
    ENDIF
ENDDO
ENDIF

END SUBROUTINE FCN

!***********************************************************************

SUBROUTINE FIT(X, NEWFSPACE, NX, NY, NZ, INFO, TOL)

! This fits a 3 dimensional gaussian of the form
! A exp (- (I-I0)T Sigma (I-I0) ) + mean
! Where I is the 3-D vector of the indexes
! To the 3 dimensional array specified by FSPACE
! This uses the Levenberg-Marquardt method. 
! Usage:
! CALL FIT(X0, FSPACE, INFO, TOL(optional))
! X0 = (\A, mean, SIGMA(1,1), SIGMA(2,2), SIGMA(3,3), SIGMA(1,2),SIGMA(2,3),SIGMA(1,3), I0(1), I0(2), I0(3) \)
!INFO is set as follows:
!    0, improper input parameters.
!    1, algorithm estimates that the relative error in the sum of squares
!       is at most TOL.
!    2, algorithm estimates that the relative error between X and the
!       solution is at most TOL.
!    3, conditions for INFO = 1 and INFO = 2 both hold.
!    4, FVEC is orthogonal to the columns of the jacobian to machine precision.
!    5, number of calls to FCN with IFLAG = 1 has reached 100*(N+1).
!    6, TOL is too small.  No further reduction in the sum of squares is
!       possible.
!    7, TOL is too small.  No further improvement in the approximate
!       solution X is possible.

IMPLICIT NONE

INTEGER*8, INTENT(IN) :: NX,NY,NZ
DOUBLE PRECISION, INTENT(IN) :: NEWFSPACE(NX,NY,NZ)
DOUBLE PRECISION, INTENT(IN), OPTIONAL :: TOL
DOUBLE PRECISION, INTENT(INOUT), DIMENSION(:) :: X
INTEGER*8, INTENT(OUT) :: INFO

DOUBLE PRECISION USETOL

IF (PRESENT(TOL)) THEN
    USETOL = TOL
ELSE
    USETOL = DEFAULTTOL
ENDIF

CALL SETFSPACE(NEWFSPACE)
!Perform Levenberg-Marquardt non-linear least square regression
CALL LMDER1 (FCN, FSIZE, 11, X, FVEC, FJAC, FSIZE, USETOL, INFO)

END SUBROUTINE FIT

!***********************************************************************

SUBROUTINE FINDPEAK (A, WIDTH, X, INFO, TOL, AMAX)

! Finds maximum value of 3D array A Selects the indexes within WIDTH
! Fits Gaussian to these indexes, then outputs the fit as X

! ASSUMES PERIODIC BOUNDARY CONDITIONS

IMPLICIT NONE

DOUBLE PRECISION, INTENT(IN), DIMENSION(:,:,:) :: A
DOUBLE PRECISION, INTENT(IN), OPTIONAL :: TOL
INTEGER*8, INTENT(IN) :: WIDTH
DOUBLE PRECISION, INTENT(OUT) :: X(11)
INTEGER*8, INTENT(OUT) :: INFO, AMAX(3)

DOUBLE PRECISION FSPACE(WIDTH*2+1,WIDTH*2+1,WIDTH*2+1)
DOUBLE PRECISION MAXA, MEANA
INTEGER*8 ASHAPE(3),I1,I2,I3,IND(3) !AMAX(3)

AMAX = MAXLOC(A)
MEANA = SUM(A)/SIZE(A)
MAXA = MAXVAL(A) - MEANA
! initialise guess for parameter array
X = (/MAXA,MEANA,1.D0,1.D0,1.D0,0.D0,0.D0,0.D0,WIDTH+1.D0,WIDTH+1.D0,WIDTH+1.D0/)
ASHAPE = SHAPE(A)

! selecting subarray to fit peak to
DO I3=1,2*WIDTH+1
    DO I2=1,2*WIDTH+1
        DO I1=1,2*WIDTH+1
            ! Ensures periodic boundary conditions
            IND = MODULO(AMAX+(/I1,I2,I3/)-2-WIDTH,ASHAPE) + 1
            FSPACE(I1,I2,I3) = A(IND(1),IND(2),IND(3))
        ENDDO
    ENDDO
ENDDO

IF(PRESENT(TOL)) THEN
    CALL FIT(X, FSPACE, WIDTH*2+1, WIDTH*2+1, WIDTH*2+1,INFO, TOL)
ELSE
    CALL FIT(X, FSPACE, WIDTH*2+1, WIDTH*2+1, WIDTH*2+1, INFO)
ENDIF

END SUBROUTINE FINDPEAK

!***********************************************************************

SUBROUTINE FINDPEAKS(FSPACE, PEAKS, AMPLITUDES, NPEAKS)

! This finds up to npeaks of a 3D periodic array
! The locations are returned in peaks as fractional index coordinates
! Amplitude gives the relative amplitude of each of the peaks
! NPEAKS gives the actual number of peaks found

IMPLICIT NONE

DOUBLE PRECISION, INTENT(IN), DIMENSION(:,:,:) :: FSPACE
INTEGER*8, INTENT(INOUT) :: NPEAKS
!INTEGER, INTENT(IN), OPTIONAL :: WIDTH
DOUBLE PRECISION, INTENT(OUT) :: PEAKS(NPEAKS,3), AMPLITUDES(NPEAKS)

INTEGER*8 WIDTH, NFOUND, FSHAPE(3), INFO, N, FMAX(3)
DOUBLE PRECISION T, X(11), PEAK(3)
DOUBLE PRECISION, ALLOCATABLE :: FSPACECOPY(:,:,:), GAUSARRAY(:,:,:)

WIDTH = DEFAULTWIDTH
FSHAPE = SHAPE(FSPACE)
ALLOCATE(FSPACECOPY(FSHAPE(1),FSHAPE(2),FSHAPE(3)))
ALLOCATE(GAUSARRAY(FSHAPE(1),FSHAPE(2),FSHAPE(3)))
FSPACECOPY = FSPACE

NFOUND = 0
DO WHILE(NFOUND.EQ.0)
    DO N=1,NPEAKS
        CALL FINDPEAK(FSPACECOPY, WIDTH, X, INFO, DEFAULTTOL, FMAX)

        IF(INFO.EQ.4.OR.INFO.EQ.5) THEN
            EXIT
        ELSE
            ! Find the location of the peak and subtract this peak from the
            ! copy of the data
            NFOUND = NFOUND + 1
            PEAK = (X(9:11) - WIDTH - 1 + FMAX)
            PEAKS(N,:) = PEAK
            AMPLITUDES(N) = X(1)
            X(9:11) = PEAK
            CALL GAUSSIAN(X,FSHAPE(1),FSHAPE(2),FSHAPE(3),GAUSARRAY)
            FSPACECOPY = FSPACECOPY - GAUSARRAY
        ENDIF
    ENDDO
    ! If we've failed to find any peaks, increase the size of the box and start again
    IF (NFOUND.EQ.0) THEN
        WIDTH = WIDTH + 1
    ENDIF
ENDDO

NPEAKS = NFOUND

END SUBROUTINE FINDPEAKS

!***********************************************************************
! FFT subroutines
!***********************************************************************
    
SUBROUTINE FFT3D(NX, NY, NZ, IN, OUT)
! calculates forward FFT in 3D
IMPLICIT NONE

INTEGER*8, INTENT(IN) :: NX, NY, NZ
COMPLEX*16, INTENT(IN) :: IN(NX, NY, NZ)
COMPLEX*16, INTENT(OUT) :: OUT(NX, NY, NZ)

INCLUDE "fftw3.f90"
INTEGER*8 PLAN_FORWARD

CALL DFFTW_PLAN_DFT_3D_(PLAN_FORWARD, NX, NY, NZ, IN, OUT, FFTW_FORWARD, FFTW_ESTIMATE )
CALL DFFTW_EXECUTE_(PLAN_FORWARD)

END SUBROUTINE FFT3D

!***********************************************************************

SUBROUTINE IFFT3D(NX, NY, NZ, IN, OUT)

! calculates UNNORMALISED inverse fourier transform so,
! IN == IFFT3D(NX,NY,NZ, FFT3D(NX,NY,NZ, IN))/(NX*NY*NZ)

IMPLICIT NONE

INTEGER*8, INTENT(IN) :: NX, NY, NZ
COMPLEX*16, INTENT(IN) :: IN(NX, NY, NZ)
COMPLEX*16, INTENT(OUT) :: OUT(NX, NY, NZ)

INCLUDE "fftw3.f90"
INTEGER*8 PLAN_BACKWARD

CALL DFFTW_PLAN_DFT_3D_(PLAN_BACKWARD,NX,NY,NZ,IN,OUT,FFTW_BACKWARD,FFTW_ESTIMATE)
CALL DFFTW_EXECUTE_(PLAN_BACKWARD)

END SUBROUTINE IFFT3D

SUBROUTINE FFT1D(N, IN, OUT)
! calculates forward FFT in 1D

IMPLICIT NONE

INTEGER*4, INTENT(IN) :: N
COMPLEX*16, INTENT(IN) :: IN(n)
COMPLEX*16, INTENT(OUT) :: OUT(n)

INCLUDE "fftw3.f90"
INTEGER*8 PLAN_FORWARD

CALL DFFTW_PLAN_DFT_1D_(PLAN_FORWARD, N, IN, OUT, FFTW_FORWARD, FFTW_ESTIMATE )
CALL DFFTW_EXECUTE_(PLAN_FORWARD)

END SUBROUTINE FFT1D

!***********************************************************************

SUBROUTINE IFFT1D(N, IN, OUT)

! calculates UNNORMALISED inverse fourier transform so,
! IN == IFFT1D(N, FFT1D(N, IN))/N

IMPLICIT NONE

INTEGER*4, INTENT(IN) :: N
COMPLEX*16, INTENT(IN) :: IN(N)
COMPLEX*16, INTENT(OUT) :: OUT(N)

INCLUDE "fftw3.f90"
INTEGER*8 PLAN_BACKWARD

CALL DFFTW_PLAN_DFT_1D_(PLAN_BACKWARD, N, IN, OUT, FFTW_BACKWARD, FFTW_ESTIMATE )
CALL DFFTW_EXECUTE_(PLAN_BACKWARD)

END SUBROUTINE IFFT1D

!***********************************************************************

!***********************************************************************

! PERIODIC FASTOVERLAP MODULE

!***********************************************************************

!***********************************************************************

END MODULE FASTOVERLAPUTILS

MODULE BULKFASTOVERLAP

INTEGER*8, SAVE, DIMENSION(:), ALLOCATABLE :: PERMGROUP,NPERMSIZE
INTEGER*8, SAVE :: NPERMGROUP, NATOMS
DOUBLE PRECISION, SAVE :: KWIDTH=0.D0

INTERFACE SETWAVEK
    MODULE PROCEDURE SETWAVEK
END INTERFACE SETWAVEK

INTERFACE PERIODICFOURIER
    MODULE PROCEDURE PERIODICFOURIER
END INTERFACE PERIODICFOURIER

INTERFACE PERIODICFOURIERPERM
    MODULE PROCEDURE PERIODICFOURIERPERM
END INTERFACE PERIODICFOURIERPERM

INTERFACE CALCFSPACE
    MODULE PROCEDURE CALCFSPACE
END INTERFACE CALCFSPACE

INTERFACE FINDDISPS
    MODULE PROCEDURE FINDDISPS
END INTERFACE FINDDISPS

INTERFACE ALIGN
    MODULE PROCEDURE ALIGN
END INTERFACE ALIGN

INTERFACE INITIALISE
    MODULE PROCEDURE INITIALISE
END INTERFACE INITIALISE

INTERFACE GETDISTANCE
    MODULE PROCEDURE GETDISTANCE
END INTERFACE GETDISTANCE

!INTERFACE 
!    DOUBLE PRECISION FUNCTION GETDISTANCE(NATOMS, COORDSA, COORDSB, PERMLIST, BOX)
!        IMPLICIT NONE
!        INTEGER*8, INTENT(IN) :: NATOMS
!        DOUBLE PRECISION, INTENT(IN) :: COORDSA(3*NATOMS), COORDSB(3*NATOMS), BOX(3)
!        INTEGER*8, INTENT(IN) :: JPERMLIST(NATOMS)
!    END FUNCTION GETDISTANCE
!END INTERFACE

CONTAINS

SUBROUTINE SETWAVEK(NWAVE,WAVEK,BOXLX,BOXLY,BOXLZ)

! NWAVE: number of wavevectors >0 in any axis
! COORDS: coordinate vector
! WAVEK: wavevectors
! FCOEFF: fourier coefficients of coordinates

IMPLICIT NONE
INTEGER*8, INTENT(IN) :: NWAVE
DOUBLE PRECISION, INTENT(IN) :: BOXLX,BOXLY,BOXLZ
DOUBLE PRECISION, INTENT(OUT) :: WAVEK(3,2*NWAVE+1,2*NWAVE+1,2*NWAVE+1)

INTEGER*8 IX,IY,IZ
DOUBLE PRECISION, PARAMETER :: TWOPI = 6.283185307179586D0
DOUBLE PRECISION KX, KY, KZ

KX = TWOPI / BOXLX
KY = TWOPI / BOXLY
KZ = TWOPI / BOXLZ

DO IX=1,2*NWAVE+1
    DO IY=1,2*NWAVE+1
        DO IZ=1,2*NWAVE+1
            WAVEK(1,IX,IY,IZ) = KX*(IX-NWAVE-1)
            WAVEK(2,IX,IY,IZ) = KY*(IY-NWAVE-1)
            WAVEK(3,IX,IY,IZ) = KZ*(IZ-NWAVE-1)
        ENDDO
    ENDDO
ENDDO

END SUBROUTINE SETWAVEK

SUBROUTINE PERIODICFOURIER(NATOMS, NWAVE, NCOEFF, COORDS, WAVEK, FCOEFF)
! Calculates fourier coefficients of a set of coordinates

! NATOMS: system size
! NWAVE: number of wavevectors modes, FCOEFF will have (2*NWAVE+1)^3 elements
! COORDS: coordinate vector
! WAVEK: wavevectors
! FCOEFF: fourier coefficients of coordinates

IMPLICIT NONE

INTEGER*8, INTENT(IN) :: NATOMS, NWAVE, NCOEFF
DOUBLE PRECISION, INTENT(IN) :: COORDS(3*NATOMS), WAVEK(3,2*NWAVE+1,2*NWAVE+1,2*NWAVE+1)
COMPLEX*16, INTENT(OUT) :: FCOEFF(NCOEFF,NCOEFF,NCOEFF)

INTEGER*8 IX,IY,IZ, J, K
DOUBLE PRECISION :: KR

DO IX=1,2*NWAVE+1
    DO IY=1,2*NWAVE+1
        DO IZ=1,2*NWAVE+1
            FCOEFF(IX,IY,IZ) = DCMPLX(0.d0,0.d0)
            DO J=1, NATOMS
                KR=0.d0
                DO K=1,3
                    KR = KR + COORDS(3*J-3+K) * WAVEK(K,IX,IY,IZ)
                ENDDO
                FCOEFF(IX,IY,IZ) = FCOEFF(IX,IY,IZ) + EXP(DCMPLX(0.d0, -KR))
            ENDDO
        ENDDO
    ENDDO
ENDDO

END SUBROUTINE PERIODICFOURIER

SUBROUTINE PERIODICFOURIERPERM(COORDS,NATOMS,NWAVE,NCOEFF,WAVEK,FCOEFF,PERMGROUP,NPERMSIZE,NPERMGROUP)
! Calculates Fourier coefficients of the different permutations of a structure.

IMPLICIT NONE

INTEGER*8, INTENT(IN) :: NATOMS, NWAVE, NPERMGROUP, NCOEFF
INTEGER*8, INTENT(IN) :: PERMGROUP(NATOMS), NPERMSIZE(NPERMGROUP)
DOUBLE PRECISION, INTENT(IN) :: COORDS(NATOMS*3),  WAVEK(3,2*NWAVE+1,2*NWAVE+1,2*NWAVE+1)
!DOUBLE PRECISION, INTENT(IN) :: BOXLX,BOXLY,BOXLZ
COMPLEX*16, INTENT(OUT) :: FCOEFF(NCOEFF,NCOEFF,NCOEFF,NPERMGROUP)

COMPLEX*16 FCOEFFDUMMY(NCOEFF,NCOEFF,NCOEFF)
DOUBLE PRECISION PDUMMY(3*NATOMS)
INTEGER*8 NDUMMY, J1, J2, PATOMS

NDUMMY=1

DO J1=1,NPERMGROUP
    PATOMS=NPERMSIZE(J1)
    DO J2=1,PATOMS
        PDUMMY(3*(J2-1)+1)=COORDS(3*(PERMGROUP(NDUMMY+J2-1)-1)+1)
        PDUMMY(3*(J2-1)+2)=COORDS(3*(PERMGROUP(NDUMMY+J2-1)-1)+2)
        PDUMMY(3*(J2-1)+3)=COORDS(3*(PERMGROUP(NDUMMY+J2-1)-1)+3)
    ENDDO
    CALL PERIODICFOURIER(PATOMS, NWAVE, NCOEFF, PDUMMY, WAVEK, FCOEFFDUMMY)
    FCOEFF(:,:,:,J1) = FCOEFFDUMMY
    NDUMMY=NDUMMY+NPERMSIZE(J1)
ENDDO

END SUBROUTINE PERIODICFOURIERPERM

SUBROUTINE CALCFSPACE(NATOMS,COORDSA,COORDSB,NWAVE,WAVEK,KWIDTH,NFSPACE,FSPACE)
!
! Calculate FASTOVERLAP real space array
! Given two bulk structures calculates the value of the overlap integral as
! FSPACE(NFSPACE, NFSPACE, NFSPACE). It does this by performing an FFT of the 
! product Fourier coefficients of both structures.
!
USE FASTOVERLAPUTILS, ONLY: FFT3D

IMPLICIT NONE

INTEGER*8, INTENT(IN) :: NATOMS, NWAVE, NFSPACE
DOUBLE PRECISION, INTENT(IN) :: KWIDTH
DOUBLE PRECISION, INTENT(IN) :: COORDSA(3*NATOMS), COORDSB(3*NATOMS)
DOUBLE PRECISION, INTENT(IN) :: WAVEK(3, 2*NWAVE+1,2*NWAVE+1,2*NWAVE+1)

DOUBLE PRECISION, INTENT(OUT) :: FSPACE(NFSPACE, NFSPACE, NFSPACE)

COMPLEX*16 FCOEFFA(NFSPACE,NFSPACE,NFSPACE,NPERMGROUP), FCOEFFB(NFSPACE,NFSPACE,NFSPACE,NPERMGROUP), COEFF
COMPLEX*16 FCOEFF(NFSPACE,NFSPACE,NFSPACE)
COMPLEX*16 FSPACECMPLX(NFSPACE,NFSPACE,NFSPACE)

INTEGER*8 I, JX, JY, JZ
DOUBLE PRECISION K2

CALL PERIODICFOURIERPERM(COORDSA,NATOMS,NWAVE,NFSPACE,WAVEK,FCOEFFA,PERMGROUP,NPERMSIZE,NPERMGROUP)
CALL PERIODICFOURIERPERM(COORDSB,NATOMS,NWAVE,NFSPACE,WAVEK,FCOEFFB,PERMGROUP,NPERMSIZE,NPERMGROUP)

FCOEFF = DCMPLX(0.D0, 0.D0)
FCOEFFB = CONJG(FCOEFFB)

DO JX=1,2*NWAVE+1
    DO JY=1,2*NWAVE+1
        DO JZ=1,2*NWAVE+1
            COEFF = DCMPLX(0.D0, 0.D0)
            K2 = -(WAVEK(1,JX,JY,JZ)**2 + WAVEK(2,JX,JY,JZ)**2 + WAVEK(3,JX,JY,JZ)**2)*KWIDTH**2
            COEFF = SUM(FCOEFFA(JX,JY,JZ,:)*FCOEFFB(JX,JY,JZ,:))*EXP(K2)
            FCOEFF(JX,JY,JZ) = COEFF
        ENDDO
    ENDDO
ENDDO

!Set average overlap to 0
FCOEFF(NWAVE+1,NWAVE+1,NWAVE+1)=(0.d0,0.d0)

CALL FFT3D(NFSPACE,NFSPACE,NFSPACE,FCOEFF,FSPACECMPLX)

FSPACE = ABS(FSPACECMPLX)

END SUBROUTINE CALCFSPACE

SUBROUTINE FINDDISPS(NATOMS,COORDSA,COORDSB,NWAVE,WAVEK,KWIDTH,NFSPACE,DISPS,NDISPS)
! 
! Performs FASTOVERLAP alignment for periodic 3D structures
!
! Calculates up to NDISPS possible displacements to align coordinates COORDSA and COORDSB
! Outputs DISPS as fractional coordinates, so DISPS must be multiplied by the lattice vector
! to obtain the full displacements
!
USE FASTOVERLAPUTILS, ONLY: FINDPEAKS
IMPLICIT NONE
INTEGER*8, INTENT(IN) :: NATOMS, NWAVE, NFSPACE
INTEGER*8, INTENT(INOUT) :: NDISPS
DOUBLE PRECISION, INTENT(IN) :: KWIDTH, COORDSA(3*NATOMS), COORDSB(3*NATOMS), WAVEK(3, 2*NWAVE+1,2*NWAVE+1,2*NWAVE+1)

DOUBLE PRECISION, INTENT(OUT) :: DISPS(NDISPS,3)

INTEGER*8 J
DOUBLE PRECISION FSPACE(NFSPACE, NFSPACE, NFSPACE), AMPLITUDES(NDISPS)

CALL CALCFSPACE(NATOMS,COORDSA,COORDSB,NWAVE,WAVEK,KWIDTH,NFSPACE,FSPACE)

CALL FINDPEAKS(FSPACE, DISPS, AMPLITUDES, NDISPS)

DISPS = DISPS - 1.D0
DO J=1,NDISPS
    DISPS(J,:) = DISPS(J,:)/(/NFSPACE,NFSPACE,NFSPACE/)
ENDDO

END SUBROUTINE FINDDISPS

SUBROUTINE ALIGN(COORDSB,COORDSA,NATOMS,DEBUG,BOXLX,BOXLY,BOXLZ,TWOD,DISTANCE,DIST2,RIGID,DISPBEST,NDISPS,BESTPERM,DISP)

! COORDSA becomes the optimal alignment of the optimal permutation of COORDSB
! DISTANCE returns 
! TWOD, RIGID aren't currently implemented
! DEBUG doesn't do anything either

USE FASTOVERLAPUTILS, ONLY: FASTLEN
IMPLICIT NONE

INTEGER*8, INTENT(IN) :: NATOMS, NDISPS
! These currently aren't used, but are included to match call signature of minpermdist
LOGICAL, INTENT(IN) :: DEBUG, TWOD, RIGID
DOUBLE PRECISION, INTENT(IN) :: BOXLX, BOXLY, BOXLZ
DOUBLE PRECISION, INTENT(INOUT) :: COORDSA(3*NATOMS), COORDSB(3*NATOMS)
DOUBLE PRECISION, INTENT(OUT) :: DISTANCE, DIST2, DISPBEST(3), DISP(3, NATOMS)
INTEGER*8, INTENT(OUT) :: BESTPERM(NATOMS)

DOUBLE PRECISION, ALLOCATABLE :: WAVEK(:,:,:,:)
DOUBLE PRECISION DISPS(NDISPS, 3), KERNELWIDTH, MAXWAVEK, BOX(3)
INTEGER*8 NWAVE, NFSPACE, FOUNDDISPS, J, J1, J2, IND1, IND2

DOUBLE PRECISION PDUMMYA(3*NATOMS), PDUMMYB(3*NATOMS), DUMMYA(3*NATOMS), DUMMYB(3*NATOMS),& 
    DUMMY(3*NATOMS), LDISTANCE, WORSTRAD, CURRDIST, MDISP(3), DISP1D(NATOMS)
INTEGER*8 SAVEPERM(NATOMS), NDUMMY, PATOMS

DOUBLE PRECISION PERMDIST

BOX = (/BOXLX, BOXLY, BOXLZ/)

! Calculate kernel width automatically if not specified
IF (KWIDTH.EQ.0.D0) THEN
    KERNELWIDTH = (BOXLX*BOXLY*BOXLZ/NATOMS)**(1.D0/3.D0) / 3.D0
ELSE
    KERNELWIDTH = KWIDTH
ENDIF

! Number of wavevectors that we need to preserve reasonable level of accuracy
MAXWAVEK = 1.5 / KERNELWIDTH
NWAVE = CEILING(2*3.14159265359/MINVAL(BOX)*MAXWAVEK, 4)
ALLOCATE(WAVEK(3,2*NWAVE+1,2*NWAVE+1,2*NWAVE+1))
CALL SETWAVEK(NWAVE,WAVEK,BOXLX,BOXLY,BOXLZ)

! Setting size of Fourier Transform array to be fast
! This also increases the resolution of the method
IF((2*NWAVE+1).LE.200) THEN
    NFSPACE = FASTLEN(4*NWAVE+3)
ELSE
    ! PROBABLY NOT THE BEST WAY TO CALCULATE THIS!
    NFSPACE = 2**CEILING(LOG(4.D0*NWAVE+3.D0)/LOG(2.D0),4)
ENDIF

FOUNDDISPS = NDISPS
! FASTOVERLAP alignment
CALL FINDDISPS(NATOMS,COORDSB,COORDSA,NWAVE,WAVEK,KERNELWIDTH,NFSPACE,DISPS,FOUNDDISPS)

! Perform permutational alignment for each displacement, keep the best
DISTANCE = HUGE(DISTANCE)
DUMMYB = COORDSB
DO J=1,FOUNDDISPS
    DISPS(J,:) = DISPS(J,:)*BOX
    
    DO J1=1,NATOMS
        DUMMYA(3*J1-2:3*J1) = COORDSA(3*J1-2:3*J1) - DISPS(J,:)
    ENDDO

    CALL FINDBESTPERMUTATION(NATOMS, DUMMYB, DUMMYA, BOXLX, BOXLY, BOXLZ, SAVEPERM, CURRDIST, DIST2, WORSTRAD)

    IF(CURRDIST.LT.DISTANCE) THEN
        DISTANCE = CURRDIST
        NDUMMY=0
        DISPBEST = DISPS(J,:)
        BESTPERM=SAVEPERM
    ENDIF
ENDDO

! Find and subtract median displacement
DO J1=1,NATOMS
    DUMMYA(3*J1-2:3*J1) = COORDSA(3*J1-2:3*J1) - DISPBEST
ENDDO

CALL GETDISPLACEMENT(DISP, NATOMS, DUMMYB, DUMMYA, BESTPERM, BOX)   

DO J=1,3
    DISP1D = DISP(J,:)
    CALL MEDIAN(DISP1D, NATOMS, MDISP(J))
ENDDO 

DISPBEST = DISPBEST + MDISP
DO J1=1,NATOMS
    DUMMYA(3*J1-2:3*J1) = COORDSA(3*J1-2:3*J1) - DISPBEST
ENDDO

! Recalculate permutational alignment
CALL FINDBESTPERMUTATION(NATOMS, DUMMYB, DUMMYA, BOXLX, BOXLY, BOXLZ, SAVEPERM, DISTANCE, DIST2, WORSTRAD)

! Find and subtract mean displacement
CALL GETDISPLACEMENT(DISP, NATOMS, DUMMYB, DUMMYA, BESTPERM, BOX)
DO J=1,3
    MDISP(J) = SUM(DISP(J,:))/NATOMS
ENDDO
DISPBEST = DISPBEST - MDISP
DO J1=1,NATOMS
    DUMMYA(3*J1-2:3*J1) = COORDSA(3*J1-2:3*J1) - DISPBEST
ENDDO

CALL GETDISTANCE(DISTANCE, NATOMS, DUMMYB, DUMMYA, BESTPERM, BOX)

DISPBEST = DISPBEST - MDISP
DO J1=1,NATOMS
    COORDSA(3*J1-2:3*J1) = DUMMYA(3*J1-2:3*J1)
ENDDO

CALL GETDISTANCE(DISTANCE, NATOMS, COORDSB, COORDSA, BESTPERM, BOX)

DO J1=1,NATOMS
    SAVEPERM(J1) = J1
    J2 = BESTPERM(J1)
    COORDSA(3*J1-2:3*J1) = DUMMYA(3*J2-2:3*J2)
ENDDO

CALL GETDISTANCE(DISTANCE, NATOMS, COORDSB, COORDSA, SAVEPERM, BOX)

DISTANCE = DISTANCE**0.5

END SUBROUTINE ALIGN

SUBROUTINE FINDBESTPERMUTATION(NATOMS, COORDSB, COORDSA, BOXLX, BOXLY, BOXLZ, SAVEPERM, LDISTANCE, DIST2, WORSTRAD)

! Find best permutational alignment of bulk structures COORDSB with COORDSA given
! PERMGROUP, NPERMSIZE specified as module variables. LDISTANCE returns the calculated
! distance^2 between the structures

IMPLICIT NONE

INTEGER*8, INTENT(IN) :: NATOMS
DOUBLE PRECISION, INTENT(IN) :: COORDSA(3*NATOMS), COORDSB(3*NATOMS), BOXLX, BOXLY, BOXLZ
INTEGER*8, INTENT(OUT) :: SAVEPERM(NATOMS)
DOUBLE PRECISION, INTENT(OUT) :: LDISTANCE, DIST2, WORSTRAD

DOUBLE PRECISION PDUMMYA(3*NATOMS), PDUMMYB(3*NATOMS), DUMMYA(3*NATOMS), DUMMYB(3*NATOMS), CURRDIST
INTEGER*8 NEWPERM(NATOMS), NDUMMY, LPERM(NATOMS), PATOMS, J, J1, J2, IND1, IND2

NDUMMY=1
DO J1=1,NATOMS
    NEWPERM(J1)=J1
ENDDO

CURRDIST = 0.D0
DO J1=1,NPERMGROUP
    PATOMS=NPERMSIZE(J1)
    DO J2=1,PATOMS
        IND2 = NEWPERM(PERMGROUP(NDUMMY+J2-1))
        PDUMMYA(3*J2-2:3*J2)=COORDSA(3*IND2-2:3*IND2)
        PDUMMYB(3*J2-2:3*J2)=COORDSB(3*IND2-2:3*IND2)
    ENDDO
    CALL MINPERM(PATOMS, PDUMMYB, PDUMMYA, BOXLX, BOXLY, BOXLZ, .TRUE., LPERM, LDISTANCE, DIST2, WORSTRAD)
    CURRDIST = CURRDIST + LDISTANCE    
    SAVEPERM(1:NATOMS)=NEWPERM(1:NATOMS)
    DO J2=1,PATOMS
        SAVEPERM(PERMGROUP(NDUMMY+J2-1))=NEWPERM(PERMGROUP(NDUMMY+LPERM(J2)-1))
    ENDDO
    NDUMMY=NDUMMY+NPERMSIZE(J1)
    NEWPERM(1:NATOMS)=SAVEPERM(1:NATOMS)
ENDDO

LDISTANCE = CURRDIST

END SUBROUTINE FINDBESTPERMUTATION

SUBROUTINE INITIALISE(NEWNATOMS, NEWPERMGROUP, NEWNPERMSIZE)

! (Re)allocates arrays that define allowed permuations

IMPLICIT NONE

INTEGER, INTENT(IN) :: NEWNATOMS, NEWPERMGROUP(:), NEWNPERMSIZE(:)


IF(.NOT.SIZE(PERMGROUP).EQ.SIZE(NEWPERMGROUP)) THEN
    IF(ALLOCATED(PERMGROUP)) THEN
        DEALLOCATE(PERMGROUP)
    ENDIF
    ALLOCATE(PERMGROUP(SIZE(NEWPERMGROUP)))
ENDIF

NPERMGROUP = SIZE(NEWNPERMSIZE)
IF(.NOT.SIZE(NPERMSIZE).EQ.SIZE(NEWNPERMSIZE)) THEN
    IF(ALLOCATED(NPERMSIZE)) THEN
        DEALLOCATE(NPERMSIZE)
    ENDIF
    ALLOCATE(NPERMSIZE(NPERMGROUP))
ENDIF

NATOMS = NEWNATOMS
PERMGROUP = NEWPERMGROUP
NPERMSIZE = NEWNPERMSIZE

END SUBROUTINE INITIALISE

SUBROUTINE GETDISTANCE(DIST, NATOMS, COORDSB, COORDSA, PERMLIST, BOX)

! Calculates distance between two bulk structures given a permutation 
! specified by PERMLIST

IMPLICIT NONE

INTEGER*8, INTENT(IN) ::NATOMS
DOUBLE PRECISION, INTENT(IN) :: COORDSA(3*NATOMS), COORDSB(3*NATOMS), BOX(3)
INTEGER*8, INTENT(IN) :: PERMLIST(NATOMS)
DOUBLE PRECISION, INTENT(OUT) :: DIST

DOUBLE PRECISION PERMDIST
INTEGER*8 J1, J2, PATOMS, NDUMMY, IND1, IND2

DIST = 0.D0
NDUMMY=0

DO J1=1,NPERMGROUP
    PATOMS=NPERMSIZE(J1)
    DO J2=1,PATOMS
        IND1 = J2+NDUMMY
        IND2 = PERMLIST(J2+NDUMMY)
        DIST = DIST + PERMDIST(COORDSB(3*IND1-2),COORDSA(3*IND2-2),BOX,.TRUE.)
    ENDDO
    NDUMMY = NDUMMY+PATOMS
ENDDO

END SUBROUTINE GETDISTANCE

SUBROUTINE GETDISPLACEMENT(DISP, NATOMS, COORDSB, COORDSA, PERMLIST, BOX)

! Calculates minimum displacement between atoms in two bulk structures given a 
! permutation specified by PERMLIST

IMPLICIT NONE

INTEGER*8, INTENT(IN) :: NATOMS
DOUBLE PRECISION, INTENT(IN) :: COORDSA(3*NATOMS), COORDSB(3*NATOMS), BOX(3)
INTEGER*8, INTENT(IN) :: PERMLIST(NATOMS)
DOUBLE PRECISION, INTENT(OUT) :: DISP(3, NATOMS)

DOUBLE PRECISION :: D(3)
INTEGER*8 J1, J2, PATOMS, NDUMMY, IND1, IND2

NDUMMY=0
DO J1=1,NPERMGROUP
    PATOMS=NPERMSIZE(J1)
    DO J2=1,PATOMS
        IND1 = J2+NDUMMY
        IND2 = PERMLIST(J2+NDUMMY)
        D = COORDSB(3*IND1-2:3*IND1) - COORDSA(3*IND2-2:3*IND2)
        D = D - BOX*ANINT(D/BOX)
        DISP(:,IND1) = D
    ENDDO
    NDUMMY = NDUMMY+PATOMS
ENDDO

END SUBROUTINE GETDISPLACEMENT

END MODULE BULKFASTOVERLAP

INCLUDE "lmder.f90"
INCLUDE "median.f90"

!SUBROUTINE FFT1D(N, IN, OUT)
!
!IMPLICIT NONE
!
!INTEGER*4, INTENT(IN) :: N
!COMPLEX*16, INTENT(IN) :: IN(n)
!COMPLEX*16, INTENT(OUT) :: OUT(n)
!
!INCLUDE "fftw3.f90"
!INTEGER*8 PLAN_FORWARD
!
!CALL DFFTW_PLAN_DFT_1D_(PLAN_FORWARD, N, IN, OUT, FFTW_FORWARD, FFTW_ESTIMATE )
!CALL DFFTW_EXECUTE_(PLAN_FORWARD)
!
!END SUBROUTINE FFT1D
!
!SUBROUTINE IFFT1D(N, IN, OUT)
!
!IMPLICIT NONE
!
!INTEGER*4, INTENT(IN) :: N
!COMPLEX*16, INTENT(IN) :: IN(N)
!COMPLEX*16, INTENT(OUT) :: OUT(N)
!
!INCLUDE "fftw3.f90"
!INTEGER*8 PLAN_BACKWARD
!
!CALL DFFTW_PLAN_DFT_1D_(PLAN_BACKWARD, N, IN, OUT, FFTW_BACKWARD, FFTW_ESTIMATE )
!CALL DFFTW_EXECUTE_(PLAN_BACKWARD)
!
!END SUBROUTINE IFFT1D
!
!SUBROUTINE FFT3D(NX, NY, NZ, IN, OUT)
!
!IMPLICIT NONE
!
!INTEGER*4, INTENT(IN) :: NX, NY, NZ
!COMPLEX*16, INTENT(IN) :: IN(NX, NY, NZ)
!COMPLEX*16, INTENT(OUT) :: OUT(NX, NY, NZ)
!
!INCLUDE "fftw3.f90"
!INTEGER*8 PLAN_FORWARD
!
!CALL DFFTW_PLAN_DFT_3D_(PLAN_FORWARD, NX, NY, NZ, IN, OUT, FFTW_FORWARD, FFTW_ESTIMATE )
!CALL DFFTW_EXECUTE_(PLAN_FORWARD)
!
!END SUBROUTINE FFT3D
!
!SUBROUTINE IFFT3D(NX, NY, NZ, IN, OUT)
!
!IMPLICIT NONE
!
!INTEGER*4, INTENT(IN) :: NX, NY, NZ
!COMPLEX*16, INTENT(IN) :: IN(NX, NY, NZ)
!COMPLEX*16, INTENT(OUT) :: OUT(NX, NY, NZ)
!
!INCLUDE "fftw3.f90"
!INTEGER*8 PLAN_FORWARD
!
!CALL DFFTW_PLAN_DFT_3D_(PLAN_FORWARD, NX, NY, NZ, IN, OUT, FFTW_BACKWARD, FFTW_ESTIMATE )
!CALL DFFTW_EXECUTE_(PLAN_FORWARD)
!
!END SUBROUTINE IFFT3D