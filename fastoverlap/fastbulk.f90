!    FASTOVERLAP
!    Copyright (C) 2017  Matthew Griffiths
!    
!    This program is free software; you can redistribute it and/or modify
!    it under the terms of the GNU General Public License as published by
!    the Free Software Foundation; either version 2 of the License, or
!    (at your option) any later version.
!    
!    This program is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU General Public License for more details.
!    
!    You should have received a copy of the GNU General Public License along
!    with this program; if not, write to the Free Software Foundation, Inc.,
!    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

INCLUDE "commons.f90"
INCLUDE "minperm.f90"
INCLUDE "fastutils.f90"


MODULE BULKFASTOVERLAP

!***********************************************************************
! PERIODIC FASTOVERLAP MODULE
!***********************************************************************
! Subroutines:
!    setwavek
!    periodicfourier
!    periodicfourierperm
!    calcfspace
!    finddisps
!    align
!    findbestpermutation
!    initialise
!    getdistance
!    getdisplacement
!***********************************************************************

USE COMMONS, ONLY : PERMGROUP, NPERMSIZE, NPERMGROUP, NATOMS

IMPLICIT NONE

! If this is set to a value other than zero, algorithm will use this value
! else it will set KWIDTH = 1/3 average interatomic separation.
DOUBLE PRECISION, SAVE :: KWIDTH=0.D0

CONTAINS

SUBROUTINE SETWAVEK(NWAVE,WAVEK,BOXLX,BOXLY,BOXLZ)

! NWAVE: number of wavevectors >0 in any axis
! COORDS: coordinate vector
! WAVEK: wavevectors
! FCOEFF: fourier coefficients of coordinates

IMPLICIT NONE
INTEGER, INTENT(IN) :: NWAVE
DOUBLE PRECISION, INTENT(IN) :: BOXLX,BOXLY,BOXLZ
DOUBLE PRECISION, INTENT(OUT) :: WAVEK(3,2*NWAVE+1,2*NWAVE+1,2*NWAVE+1)

INTEGER IX,IY,IZ
DOUBLE PRECISION, PARAMETER :: TWOPI = 6.283185307179586D0
DOUBLE PRECISION KX, KY, KZ

KX = TWOPI / BOXLX
KY = TWOPI / BOXLY
KZ = TWOPI / BOXLZ

DO IX=1,2*NWAVE+1
    DO IY=1,2*NWAVE+1
        DO IZ=1,2*NWAVE+1
            WAVEK(1,IX,IY,IZ) = KX*(IX-NWAVE-1)
            WAVEK(2,IX,IY,IZ) = KY*(IY-NWAVE-1)
            WAVEK(3,IX,IY,IZ) = KZ*(IZ-NWAVE-1)
        ENDDO
    ENDDO
ENDDO

END SUBROUTINE SETWAVEK

SUBROUTINE PERIODICFOURIER(NATOMS, NWAVE, NCOEFF, COORDS, WAVEK, FCOEFF)
! Calculates fourier coefficients of a set of coordinates

! NATOMS: system size
! NWAVE: number of wavevectors modes, FCOEFF will have (2*NWAVE+1)^3 elements
! COORDS: coordinate vector
! WAVEK: wavevectors
! FCOEFF: fourier coefficients of coordinates

IMPLICIT NONE

INTEGER, INTENT(IN) :: NATOMS, NWAVE, NCOEFF
DOUBLE PRECISION, INTENT(IN) :: COORDS(3*NATOMS), WAVEK(3,2*NWAVE+1,2*NWAVE+1,2*NWAVE+1)
COMPLEX*16, INTENT(OUT) :: FCOEFF(NCOEFF,NCOEFF,NCOEFF)

INTEGER IX,IY,IZ, J, K
DOUBLE PRECISION :: KR

DO IX=1,2*NWAVE+1
    DO IY=1,2*NWAVE+1
        DO IZ=1,2*NWAVE+1
            FCOEFF(IX,IY,IZ) = DCMPLX(0.d0,0.d0)
            DO J=1, NATOMS
                KR=0.d0
                DO K=1,3
                    KR = KR + COORDS(3*J-3+K) * WAVEK(K,IX,IY,IZ)
                ENDDO
                FCOEFF(IX,IY,IZ) = FCOEFF(IX,IY,IZ) + EXP(DCMPLX(0.d0, -KR))
            ENDDO
        ENDDO
    ENDDO
ENDDO

END SUBROUTINE PERIODICFOURIER

SUBROUTINE PERIODICFOURIERPERM(COORDS,NATOMS,NWAVE,NCOEFF,WAVEK,FCOEFF,NPERMGROUP)!,PERMGROUP,NPERMSIZE,NPERMGROUP)
! Calculates Fourier coefficients of the different permutations of a structure.

IMPLICIT NONE

INTEGER, INTENT(IN) :: NPERMGROUP
INTEGER, INTENT(IN) :: NATOMS, NWAVE, NCOEFF
!INTEGER, INTENT(IN) :: PERMGROUP(NATOMS), NPERMSIZE(NPERMGROUP)
DOUBLE PRECISION, INTENT(IN) :: COORDS(NATOMS*3),  WAVEK(3,2*NWAVE+1,2*NWAVE+1,2*NWAVE+1)
!DOUBLE PRECISION, INTENT(IN) :: BOXLX,BOXLY,BOXLZ
COMPLEX*16, INTENT(OUT) :: FCOEFF(NCOEFF,NCOEFF,NCOEFF,NPERMGROUP)

COMPLEX*16 FCOEFFDUMMY(NCOEFF,NCOEFF,NCOEFF)
DOUBLE PRECISION PDUMMY(3*NATOMS)
INTEGER NDUMMY, J1, J2, PATOMS

NDUMMY=1

DO J1=1,NPERMGROUP
    PATOMS=NPERMSIZE(J1)
    DO J2=1,PATOMS
        PDUMMY(3*(J2-1)+1)=COORDS(3*(PERMGROUP(NDUMMY+J2-1)-1)+1)
        PDUMMY(3*(J2-1)+2)=COORDS(3*(PERMGROUP(NDUMMY+J2-1)-1)+2)
        PDUMMY(3*(J2-1)+3)=COORDS(3*(PERMGROUP(NDUMMY+J2-1)-1)+3)
    ENDDO
    CALL PERIODICFOURIER(PATOMS, NWAVE, NCOEFF, PDUMMY, WAVEK, FCOEFFDUMMY)
    FCOEFF(:,:,:,J1) = FCOEFFDUMMY
    NDUMMY=NDUMMY+NPERMSIZE(J1)
ENDDO

END SUBROUTINE PERIODICFOURIERPERM

!SUBROUTINE CALCFOURIERCOEFFS(NATOMS,COORDSA,COORDSB,NWAVE,WAVEK,KWIDTH,FCOEFF)
!
!IMPLICIT NONE
!
!INTEGER, INTENT(IN) :: NATOMS, NWAVE!, NPERMGROUP
!DOUBLE PRECISION, INTENT(IN) :: KWIDTH
!DOUBLE PRECISION, INTENT(IN) :: COORDSA(3*NATOMS), COORDSB(3*NATOMS)
!DOUBLE PRECISION, INTENT(IN) :: WAVEK(3, 2*NWAVE+1,2*NWAVE+1,2*NWAVE+1)
!
!COMPLEX*16 , INTENT(OUT) :: FCOEFF(NFSPACE,NFSPACE,NFSPACE)
!
!COMPLEX*16 FCOEFFA(NFSPACE,NFSPACE,NFSPACE,NPERMGROUP), FCOEFFB(NFSPACE,NFSPACE,NFSPACE,NPERMGROUP), COEFF
!COMPLEX*16 FSPACECMPLX(NFSPACE,NFSPACE,NFSPACE)
!
!INTEGER I, JX, JY, JZ
!DOUBLE PRECISION K2
!
!CALL PERIODICFOURIERPERM(COORDSA,NATOMS,NWAVE,NFSPACE,WAVEK,FCOEFFA,NPERMGROUP)!,PERMGROUP,NPERMSIZE,NPERMGROUP)
!CALL PERIODICFOURIERPERM(COORDSB,NATOMS,NWAVE,NFSPACE,WAVEK,FCOEFFB,NPERMGROUP)!,PERMGROUP,NPERMSIZE,NPERMGROUP)
!
!FCOEFF = DCMPLX(0.D0, 0.D0)
!FCOEFFB = CONJG(FCOEFFB)
!
!DO JX=1,2*NWAVE+1
!    DO JY=1,2*NWAVE+1
!        DO JZ=1,2*NWAVE+1
!            COEFF = DCMPLX(0.D0, 0.D0)
!            K2 = -(WAVEK(1,JX,JY,JZ)**2 + WAVEK(2,JX,JY,JZ)**2 + WAVEK(3,JX,JY,JZ)**2)*KWIDTH**2
!            COEFF = SUM(FCOEFFA(JX,JY,JZ,:)*FCOEFFB(JX,JY,JZ,:))*EXP(K2)
!            FCOEFF(JX,JY,JZ) = COEFF
!        ENDDO
!    ENDDO
!ENDDO
!
!END SUBROUTINE CALCFOURIERCOEFFS

SUBROUTINE CALCFSPACE(NATOMS,COORDSA,COORDSB,NWAVE,WAVEK,KWIDTH,NFSPACE,FSPACE)!,NPERMGROUP)
!
! Calculate FASTOVERLAP real space array
! Given two bulk structures calculates the value of the overlap integral as
! FSPACE(NFSPACE, NFSPACE, NFSPACE). It does this by performing an FFT of the 
! product Fourier coefficients of both structures.
!
USE FASTOVERLAPUTILS, ONLY: FFT3D

IMPLICIT NONE

INTEGER, INTENT(IN) :: NATOMS, NWAVE, NFSPACE!, NPERMGROUP
DOUBLE PRECISION, INTENT(IN) :: KWIDTH
DOUBLE PRECISION, INTENT(IN) :: COORDSA(3*NATOMS), COORDSB(3*NATOMS)
DOUBLE PRECISION, INTENT(IN) :: WAVEK(3, 2*NWAVE+1,2*NWAVE+1,2*NWAVE+1)

DOUBLE PRECISION, INTENT(OUT) :: FSPACE(NFSPACE, NFSPACE, NFSPACE)

COMPLEX*16 FCOEFFA(NFSPACE,NFSPACE,NFSPACE,NPERMGROUP), FCOEFFB(NFSPACE,NFSPACE,NFSPACE,NPERMGROUP), COEFF
COMPLEX*16 FCOEFF(NFSPACE,NFSPACE,NFSPACE)
COMPLEX*16 FSPACECMPLX(NFSPACE,NFSPACE,NFSPACE)

INTEGER I, JX, JY, JZ
DOUBLE PRECISION K2

CALL PERIODICFOURIERPERM(COORDSA,NATOMS,NWAVE,NFSPACE,WAVEK,FCOEFFA,NPERMGROUP)!,PERMGROUP,NPERMSIZE,NPERMGROUP)
CALL PERIODICFOURIERPERM(COORDSB,NATOMS,NWAVE,NFSPACE,WAVEK,FCOEFFB,NPERMGROUP)!,PERMGROUP,NPERMSIZE,NPERMGROUP)

FCOEFF = DCMPLX(0.D0, 0.D0)
FCOEFFB = CONJG(FCOEFFB)

DO JX=1,2*NWAVE+1
    DO JY=1,2*NWAVE+1
        DO JZ=1,2*NWAVE+1
            COEFF = DCMPLX(0.D0, 0.D0)
            K2 = -(WAVEK(1,JX,JY,JZ)**2 + WAVEK(2,JX,JY,JZ)**2 + WAVEK(3,JX,JY,JZ)**2)*KWIDTH**2
            COEFF = SUM(FCOEFFA(JX,JY,JZ,:)*FCOEFFB(JX,JY,JZ,:))*EXP(K2)
            FCOEFF(JX,JY,JZ) = COEFF
        ENDDO
    ENDDO
ENDDO

!Set average overlap to 0
FCOEFF(NWAVE+1,NWAVE+1,NWAVE+1)=(0.d0,0.d0)

CALL FFT3D(NFSPACE,NFSPACE,NFSPACE,FCOEFF,FSPACECMPLX)

FSPACE = ABS(FSPACECMPLX)

END SUBROUTINE CALCFSPACE

SUBROUTINE FINDDISPS(NATOMS,COORDSA,COORDSB,NWAVE,WAVEK,KWIDTH,NFSPACE,DISPS,NDISPS)
! 
! Performs FASTOVERLAP alignment for periodic 3D structures
!
! Calculates up to NDISPS possible displacements to align coordinates COORDSA and COORDSB
! Outputs DISPS as fractional coordinates, so DISPS must be multiplied by the lattice vector
! to obtain the full displacements
!
USE FASTOVERLAPUTILS, ONLY: FINDPEAKS
IMPLICIT NONE
INTEGER, INTENT(IN) :: NATOMS, NWAVE, NFSPACE
INTEGER, INTENT(INOUT) :: NDISPS
DOUBLE PRECISION, INTENT(IN) :: KWIDTH, COORDSA(3*NATOMS), COORDSB(3*NATOMS), WAVEK(3, 2*NWAVE+1,2*NWAVE+1,2*NWAVE+1)

DOUBLE PRECISION, INTENT(OUT) :: DISPS(NDISPS,3)

INTEGER J
DOUBLE PRECISION FSPACE(NFSPACE, NFSPACE, NFSPACE), AMPLITUDES(NDISPS)

CALL CALCFSPACE(NATOMS,COORDSA,COORDSB,NWAVE,WAVEK,KWIDTH,NFSPACE,FSPACE)!,NPERMGROUP)

CALL FINDPEAKS(FSPACE, DISPS, AMPLITUDES, NDISPS)

DISPS = DISPS - 1.D0
DO J=1,NDISPS
    DISPS(J,:) = DISPS(J,:)/(/NFSPACE,NFSPACE,NFSPACE/)
ENDDO

END SUBROUTINE FINDDISPS

SUBROUTINE ALIGN(COORDSB,COORDSA,NATOMS,DEBUG,BOXLX,BOXLY,BOXLZ,TWOD,DISTANCE,DIST2,RIGID,DISPBEST,NDISPS,BESTPERM,DISP)

! COORDSA becomes the optimal alignment of the optimal permutation of COORDSB
! DISTANCE returns 
! TWOD, RIGID aren't currently implemented
! DEBUG doesn't do anything either
!USE COMMONS, ONLY : PERMGROUP, NPERMSIZE, NPERMGROUP
USE FASTOVERLAPUTILS, ONLY: FASTLEN
IMPLICIT NONE

INTEGER, INTENT(IN) :: NATOMS, NDISPS
! These currently aren't used, but are included to match call signature of minpermdist
LOGICAL, INTENT(IN) :: DEBUG, TWOD, RIGID
DOUBLE PRECISION, INTENT(IN) :: BOXLX, BOXLY, BOXLZ
DOUBLE PRECISION, INTENT(INOUT) :: COORDSA(3*NATOMS), COORDSB(3*NATOMS)
DOUBLE PRECISION, INTENT(OUT) :: DISTANCE, DIST2, DISPBEST(3), DISP(3, NATOMS)
INTEGER, INTENT(OUT) :: BESTPERM(NATOMS)

DOUBLE PRECISION, ALLOCATABLE :: WAVEK(:,:,:,:)
DOUBLE PRECISION DISPS(NDISPS, 3), KERNELWIDTH, MAXWAVEK, BOX(3)
INTEGER NWAVE, NFSPACE, FOUNDDISPS, J, J1, J2, IND1, IND2

DOUBLE PRECISION PDUMMYA(3*NATOMS), PDUMMYB(3*NATOMS), DUMMYA(3*NATOMS), DUMMYB(3*NATOMS),& 
    DUMMY(3*NATOMS), LDISTANCE, WORSTRAD, CURRDIST, MDISP(3), DISP1D(NATOMS)
INTEGER SAVEPERM(NATOMS), NDUMMY, PATOMS

DOUBLE PRECISION PERMDIST

BOX = (/BOXLX, BOXLY, BOXLZ/)

! Calculate kernel width automatically if not specified
IF (KWIDTH.EQ.0.D0) THEN
    KERNELWIDTH = (BOXLX*BOXLY*BOXLZ/NATOMS)**(1.D0/3.D0) / 3.D0
ELSE
    KERNELWIDTH = KWIDTH
ENDIF

! Number of wavevectors that we need to preserve reasonable level of accuracy
MAXWAVEK = 1.5 / KERNELWIDTH
NWAVE = CEILING(2*3.14159265359/MINVAL(BOX)*MAXWAVEK, 4)
ALLOCATE(WAVEK(3,2*NWAVE+1,2*NWAVE+1,2*NWAVE+1))
CALL SETWAVEK(NWAVE,WAVEK,BOXLX,BOXLY,BOXLZ)

! Setting size of Fourier Transform array to be fast
! This also increases the resolution of the method
IF((2*NWAVE+1).LE.200) THEN
    NFSPACE = FASTLEN(4*NWAVE+3)
ELSE
    ! PROBABLY NOT THE BEST WAY TO CALCULATE THIS!
    NFSPACE = 2**CEILING(LOG(4.D0*NWAVE+3.D0)/LOG(2.D0),4)
ENDIF

FOUNDDISPS = NDISPS
! FASTOVERLAP alignment
CALL FINDDISPS(NATOMS,COORDSB,COORDSA,NWAVE,WAVEK,KERNELWIDTH,NFSPACE,DISPS,FOUNDDISPS)


! Perform permutational alignment for each displacement, keep the best
DISTANCE = HUGE(DISTANCE)
DUMMYB = COORDSB
DO J=1,FOUNDDISPS
    DISPS(J,:) = DISPS(J,:)*BOX
    
    DO J1=1,NATOMS
        DUMMYA(3*J1-2:3*J1) = COORDSA(3*J1-2:3*J1) - DISPS(J,:)
    ENDDO
    CALL FINDBESTPERMUTATION(NATOMS, DUMMYB, DUMMYA, BOXLX, BOXLY, BOXLZ, SAVEPERM, CURRDIST, DIST2, WORSTRAD)
    IF(CURRDIST.LT.DISTANCE) THEN
        DISTANCE = CURRDIST
        NDUMMY=0
        DISPBEST = DISPS(J,:)
        BESTPERM=SAVEPERM
    ENDIF
ENDDO

! Find and subtract median displacement
DO J1=1,NATOMS
    DUMMYA(3*J1-2:3*J1) = COORDSA(3*J1-2:3*J1) - DISPBEST
ENDDO

CALL GETDISPLACEMENT(DISP, NATOMS, DUMMYB, DUMMYA, BESTPERM, BOX)   

DO J=1,3
    DISP1D = DISP(J,:)
    CALL MEDIAN(DISP1D, NATOMS, MDISP(J))
ENDDO 

DISPBEST = DISPBEST + MDISP
DO J1=1,NATOMS
    DUMMYA(3*J1-2:3*J1) = COORDSA(3*J1-2:3*J1) - DISPBEST
ENDDO

! Recalculate permutational alignment
CALL FINDBESTPERMUTATION(NATOMS, DUMMYB, DUMMYA, BOXLX, BOXLY, BOXLZ, SAVEPERM, DISTANCE, DIST2, WORSTRAD)

! Find and subtract mean displacement
CALL GETDISPLACEMENT(DISP, NATOMS, DUMMYB, DUMMYA, BESTPERM, BOX)
DO J=1,3
    MDISP(J) = SUM(DISP(J,:))/NATOMS
ENDDO
DISPBEST = DISPBEST - MDISP
DO J1=1,NATOMS
    DUMMYA(3*J1-2:3*J1) = COORDSA(3*J1-2:3*J1) - DISPBEST
ENDDO

CALL GETDISTANCE(DISTANCE, NATOMS, DUMMYB, DUMMYA, BESTPERM, BOX)

DISPBEST = DISPBEST - MDISP
DO J1=1,NATOMS
    COORDSA(3*J1-2:3*J1) = DUMMYA(3*J1-2:3*J1)
ENDDO

CALL GETDISTANCE(DISTANCE, NATOMS, COORDSB, COORDSA, BESTPERM, BOX)

DO J1=1,NATOMS
    SAVEPERM(J1) = J1
    J2 = BESTPERM(J1)
    COORDSA(3*J1-2:3*J1) = DUMMYA(3*J2-2:3*J2)
ENDDO

CALL GETDISTANCE(DISTANCE, NATOMS, COORDSB, COORDSA, SAVEPERM, BOX)

DISTANCE = DISTANCE**0.5

END SUBROUTINE ALIGN

SUBROUTINE FINDBESTPERMUTATION(NATOMS, COORDSB, COORDSA, BOXLX, BOXLY, BOXLZ, SAVEPERM, LDISTANCE, DIST2, WORSTRAD)

! Find best permutational alignment of bulk structures COORDSB with COORDSA given
! PERMGROUP, NPERMSIZE specified as module variables. LDISTANCE returns the calculated
! distance^2 between the structures
!USE COMMONS, ONLY :: PERMGROUP, NPERMSIZE, NPERMGROUP!, NATOMS
IMPLICIT NONE

INTEGER, INTENT(IN) :: NATOMS
DOUBLE PRECISION, INTENT(IN) :: COORDSA(3*NATOMS), COORDSB(3*NATOMS), BOXLX, BOXLY, BOXLZ
INTEGER, INTENT(OUT) :: SAVEPERM(NATOMS)
DOUBLE PRECISION, INTENT(OUT) :: LDISTANCE, DIST2, WORSTRAD

DOUBLE PRECISION PDUMMYA(3*NATOMS), PDUMMYB(3*NATOMS), DUMMYA(3*NATOMS), DUMMYB(3*NATOMS), CURRDIST
INTEGER NEWPERM(NATOMS), NDUMMY, J, J1, J2, IND1, IND2
INTEGER PATOMS, LPERM(NATOMS)


NDUMMY=1
DO J1=1,NATOMS
    NEWPERM(J1)=J1
ENDDO

CURRDIST = 0.D0
DO J1=1,NPERMGROUP
    PATOMS=INT(NPERMSIZE(J1),4)
    DO J2=1,PATOMS
        IND2 = NEWPERM(PERMGROUP(NDUMMY+J2-1))
        PDUMMYA(3*J2-2:3*J2)=COORDSA(3*IND2-2:3*IND2)
        PDUMMYB(3*J2-2:3*J2)=COORDSB(3*IND2-2:3*IND2)
    ENDDO
    CALL MINPERM(PATOMS, PDUMMYB, PDUMMYA, BOXLX, BOXLY, BOXLZ, .TRUE., LPERM, LDISTANCE, DIST2, WORSTRAD)
    CURRDIST = CURRDIST + LDISTANCE    
    SAVEPERM(1:NATOMS)=NEWPERM(1:NATOMS)
    DO J2=1,INT(PATOMS,4)
        SAVEPERM(PERMGROUP(NDUMMY+J2-1))=NEWPERM(PERMGROUP(NDUMMY+INT(LPERM(J2),4)-1))
    ENDDO
    NDUMMY=NDUMMY+NPERMSIZE(J1)
    NEWPERM(1:NATOMS)=SAVEPERM(1:NATOMS)
ENDDO

LDISTANCE = CURRDIST

END SUBROUTINE FINDBESTPERMUTATION

SUBROUTINE INITIALISE(NEWNATOMS, NEWPERMGROUP, NEWNPERMSIZE)

! (Re)allocates arrays that define allowed permuations
IMPLICIT NONE

INTEGER, INTENT(IN) :: NEWNATOMS, NEWPERMGROUP(:), NEWNPERMSIZE(:)


IF(.NOT.SIZE(PERMGROUP).EQ.SIZE(NEWPERMGROUP)) THEN
    IF(ALLOCATED(PERMGROUP)) THEN
        DEALLOCATE(PERMGROUP)
    ENDIF
    ALLOCATE(PERMGROUP(SIZE(NEWPERMGROUP)))
ENDIF

NPERMGROUP = SIZE(NEWNPERMSIZE)
IF(.NOT.SIZE(NPERMSIZE).EQ.SIZE(NEWNPERMSIZE)) THEN
    IF(ALLOCATED(NPERMSIZE)) THEN
        DEALLOCATE(NPERMSIZE)
    ENDIF
    ALLOCATE(NPERMSIZE(NPERMGROUP))
ENDIF

NATOMS = NEWNATOMS
PERMGROUP = NEWPERMGROUP
NPERMSIZE = NEWNPERMSIZE

END SUBROUTINE INITIALISE

SUBROUTINE GETDISTANCE(DIST, NATOMS, COORDSB, COORDSA, PERMLIST, BOX)

! Calculates distance between two bulk structures given a permutation 
! specified by PERMLIST
!USE COMMONS, ONLY : PERMGROUP, NPERMSIZE, NPERMGROUP
IMPLICIT NONE

INTEGER, INTENT(IN) ::NATOMS
DOUBLE PRECISION, INTENT(IN) :: COORDSA(3*NATOMS), COORDSB(3*NATOMS), BOX(3)
INTEGER, INTENT(IN) :: PERMLIST(NATOMS)
DOUBLE PRECISION, INTENT(OUT) :: DIST

DOUBLE PRECISION PERMDIST
INTEGER J1, J2, PATOMS, NDUMMY, IND1, IND2

DIST = 0.D0
NDUMMY=0

DO J1=1,NPERMGROUP
    PATOMS=NPERMSIZE(J1)
    DO J2=1,PATOMS
        IND1 = J2+NDUMMY
        IND2 = PERMLIST(J2+NDUMMY)
        DIST = DIST + PERMDIST(COORDSB(3*IND1-2),COORDSA(3*IND2-2),BOX,.TRUE.)
    ENDDO
    NDUMMY = NDUMMY+PATOMS
ENDDO

END SUBROUTINE GETDISTANCE

SUBROUTINE GETDISPLACEMENT(DISP, NATOMS, COORDSB, COORDSA, PERMLIST, BOX)

! Calculates minimum displacement between atoms in two bulk structures given a 
! permutation specified by PERMLIST
!USE COMMONS, ONLY : PERMGROUP, NPERMSIZE, NPERMGROUP
IMPLICIT NONE

INTEGER, INTENT(IN) :: NATOMS
DOUBLE PRECISION, INTENT(IN) :: COORDSA(3*NATOMS), COORDSB(3*NATOMS), BOX(3)
INTEGER, INTENT(IN) :: PERMLIST(NATOMS)
DOUBLE PRECISION, INTENT(OUT) :: DISP(3, NATOMS)

DOUBLE PRECISION :: D(3)
INTEGER J1, J2, PATOMS, NDUMMY, IND1, IND2

NDUMMY=0
DO J1=1,NPERMGROUP
    PATOMS=NPERMSIZE(J1)
    DO J2=1,PATOMS
        IND1 = J2+NDUMMY
        IND2 = PERMLIST(J2+NDUMMY)
        D = COORDSB(3*IND1-2:3*IND1) - COORDSA(3*IND2-2:3*IND2)
        D = D - BOX*ANINT(D/BOX)
        DISP(:,IND1) = D
    ENDDO
    NDUMMY = NDUMMY+PATOMS
ENDDO

END SUBROUTINE GETDISPLACEMENT

END MODULE BULKFASTOVERLAP