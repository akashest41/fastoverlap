!    FASTOVERLAP
!    Copyright (C) 2017  Matthew Griffiths
!    
!    This program is free software; you can redistribute it and/or modify
!    it under the terms of the GNU General Public License as published by
!    the Free Software Foundation; either version 2 of the License, or
!    (at your option) any later version.
!    
!    This program is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU General Public License for more details.
!    
!    You should have received a copy of the GNU General Public License along
!    with this program; if not, write to the Free Software Foundation, Inc.,
!    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

INCLUDE "commons.f90"
INCLUDE "fastutils.f90"


MODULE BULKFASTOVERLAP

!***********************************************************************
! PERIODIC FASTOVERLAP MODULE
!***********************************************************************
! Subroutines:
!    setwavek
!    periodicfourier
!    periodicfourierperm
!    calcfspace
!    finddisps
!    align
!    findbestpermutation
!    initialise
!    getdistance
!    getdisplacement
!***********************************************************************

USE COMMONS, ONLY : PERMGROUP, NPERMSIZE, NPERMGROUP, NATOMS, MYUNIT, NSETS, SETS
USE FASTOVERLAPUTILS, ONLY : DUMMYA, DUMMYB, XBESTA, XBESTASAVE

IMPLICIT NONE

! If this is set to a value other than zero, algorithm will use this value
! else it will set KWIDTH = 1/3 average interatomic separation.
DOUBLE PRECISION, SAVE :: KWIDTH=0.D0
LOGICAL, SAVE :: OHCELLTSAVE
DOUBLE PRECISION, SAVE :: OHOPSMAT(3,3,48)

DATA OHOPSMAT / &
 & 1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  1.00000000000D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  1.00000000000D0,   & 
 & -1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  -1.00000000000D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  1.00000000000D0,   & 
 & 0.0D0,  0.0D0,  1.00000000000D0,   & 
 & 1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  1.00000000000D0,  0.0D0,   & 
 & 0.0D0,  -1.00000000000D0,  0.0D0,   & 
 & 1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  1.00000000000D0,   & 
 & -1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  -1.00000000000D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  -1.00000000000D0,   & 
 & 0.0D0,  0.0D0,  -1.00000000000D0,   & 
 & -1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  1.00000000000D0,  0.0D0,   & 
 & 0.0D0,  1.00000000000D0,  0.0D0,   & 
 & -1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  1.00000000000D0,   & 
 & 1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  1.00000000000D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  -1.00000000000D0,   & 
 & 0.0D0,  0.0D0,  1.00000000000D0,   & 
 & -1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  -1.00000000000D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  -1.00000000000D0,   & 
 & 1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  -1.00000000000D0,  0.0D0,   & 
 & 0.0D0,  1.00000000000D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  1.00000000000D0,   & 
 & 1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  -1.00000000000D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  -1.00000000000D0,   & 
 & 1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  1.00000000000D0,   & 
 & 0.0D0,  -1.00000000000D0,  0.0D0,   & 
 & 1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  -1.00000000000D0,   & 
 & 0.0D0,  1.00000000000D0,  0.0D0,   & 
 & 1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  -1.00000000000D0,   & 
 & -1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  -1.00000000000D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  1.00000000000D0,   & 
 & 1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  -1.00000000000D0,  0.0D0,   & 
 & 0.0D0,  1.00000000000D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  -1.00000000000D0,   & 
 & -1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  -1.00000000000D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  1.00000000000D0,   & 
 & -1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  1.00000000000D0,   & 
 & 0.0D0,  1.00000000000D0,  0.0D0,   & 
 & -1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  -1.00000000000D0,   & 
 & 0.0D0,  -1.00000000000D0,  0.0D0,   & 
 & -1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  -1.00000000000D0,   & 
 & 1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  1.00000000000D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  1.00000000000D0,   & 
 & -1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  1.00000000000D0,  0.0D0,   & 
 & 1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  -1.00000000000D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  -1.00000000000D0,   & 
 & -1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  1.00000000000D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  -1.00000000000D0,   & 
 & 1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  1.00000000000D0,   & 
 & 0.0D0,  -1.00000000000D0,  0.0D0,   & 
 & -1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  -1.00000000000D0,   & 
 & 0.0D0,  -1.00000000000D0,  0.0D0,   & 
 & 1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  -1.00000000000D0,   & 
 & 0.0D0,  1.00000000000D0,  0.0D0,   & 
 & -1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  1.00000000000D0,   & 
 & 0.0D0,  1.00000000000D0,  0.0D0,   & 
 & 0.0D0,  -1.00000000000D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  -1.00000000000D0,   & 
 & -1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  1.00000000000D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  1.00000000000D0,   & 
 & -1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  -1.00000000000D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  1.00000000000D0,   & 
 & 1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  1.00000000000D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  -1.00000000000D0,   & 
 & 1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  -1.00000000000D0,  0.0D0,   & 
 & -1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  -1.00000000000D0,   & 
 & 0.0D0,  1.00000000000D0,  0.0D0,   & 
 & 1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  -1.00000000000D0,   & 
 & -1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  1.00000000000D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  1.00000000000D0,   & 
 & 1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  -1.00000000000D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  1.00000000000D0,   & 
 & 0.0D0,  1.00000000000D0,  0.0D0,   & 
 & -1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  -1.00000000000D0,   & 
 & 0.0D0,  -1.00000000000D0,  0.0D0,   & 
 & 1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  -1.00000000000D0,   & 
 & 0.0D0,  0.0D0,  -1.00000000000D0,   & 
 & 0.0D0,  1.00000000000D0,  0.0D0,   & 
 & -1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  1.00000000000D0,   & 
 & 0.0D0,  -1.00000000000D0,  0.0D0,   & 
 & -1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  -1.00000000000D0,   & 
 & 0.0D0,  -1.00000000000D0,  0.0D0,   & 
 & 1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  1.00000000000D0,   & 
 & 0.0D0,  1.00000000000D0,  0.0D0,   & 
 & 1.00000000000D0,  0.0D0,  0.0D0,   & 
 & -1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  -1.00000000000D0,   & 
 & 0.0D0,  1.00000000000D0,  0.0D0,   & 
 & 1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  1.00000000000D0,   & 
 & 0.0D0,  1.00000000000D0,  0.0D0,   & 
 & -1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  1.00000000000D0,   & 
 & 0.0D0,  -1.00000000000D0,  0.0D0,   & 
 & 1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  -1.00000000000D0,   & 
 & 0.0D0,  -1.00000000000D0,  0.0D0,   & 
 & 0.0D0,  1.00000000000D0,  0.0D0,   & 
 & 1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  1.00000000000D0,   & 
 & 0.0D0,  -1.00000000000D0,  0.0D0,   & 
 & -1.00000000000D0,  0.0D0,  0.0D0,   & 
 & 0.0D0,  0.0D0,  1.00000000000D0 /


CONTAINS

SUBROUTINE SETWAVEK(NWAVE,WAVEK,BOXLX,BOXLY,BOXLZ)

! NWAVE: number of wavevectors >0 in any axis
! COORDS: coordinate vector
! WAVEK: wavevectors
! FCOEFF: fourier coefficients of coordinates

IMPLICIT NONE
INTEGER, INTENT(IN) :: NWAVE
DOUBLE PRECISION, INTENT(IN) :: BOXLX,BOXLY,BOXLZ
DOUBLE PRECISION, INTENT(OUT) :: WAVEK(3,2*NWAVE+1,2*NWAVE+1,2*NWAVE+1)

INTEGER IX,IY,IZ
DOUBLE PRECISION, PARAMETER :: TWOPI = 6.283185307179586D0
DOUBLE PRECISION KX, KY, KZ

KX = TWOPI / BOXLX
KY = TWOPI / BOXLY
KZ = TWOPI / BOXLZ

DO IX=1,2*NWAVE+1
    DO IY=1,2*NWAVE+1
        DO IZ=1,2*NWAVE+1
            WAVEK(1,IX,IY,IZ) = KX*(IX-NWAVE-1)
            WAVEK(2,IX,IY,IZ) = KY*(IY-NWAVE-1)
            WAVEK(3,IX,IY,IZ) = KZ*(IZ-NWAVE-1)
        ENDDO
    ENDDO
ENDDO

END SUBROUTINE SETWAVEK

SUBROUTINE PERIODICFOURIER(NATOMS, NWAVE, NCOEFF, COORDS, WAVEK, FCOEFF)
! Calculates fourier coefficients of a set of coordinates

! NATOMS: system size
! NWAVE: number of wavevectors modes, FCOEFF will have (2*NWAVE+1)^3 elements
! COORDS: coordinate vector
! WAVEK: wavevectors
! FCOEFF: fourier coefficients of coordinates

IMPLICIT NONE

INTEGER, INTENT(IN) :: NATOMS, NWAVE, NCOEFF
DOUBLE PRECISION, INTENT(IN) :: COORDS(3*NATOMS), WAVEK(3,2*NWAVE+1,2*NWAVE+1,2*NWAVE+1)
COMPLEX*16, INTENT(OUT) :: FCOEFF(NCOEFF,NCOEFF,NCOEFF)

INTEGER IX,IY,IZ, J, K
DOUBLE PRECISION :: KR

FCOEFF = DCMPLX(0.d0,0.d0)
DO IX=1,2*NWAVE+1
    DO IY=1,2*NWAVE+1
        DO IZ=1,2*NWAVE+1
!            FCOEFF(IX,IY,IZ) = DCMPLX(0.d0,0.d0)
            DO J=1, NATOMS
                KR=0.d0
                DO K=1,3
                    KR = KR + COORDS(3*J-3+K) * WAVEK(K,IX,IY,IZ)
                ENDDO
                FCOEFF(IX,IY,IZ) = FCOEFF(IX,IY,IZ) + EXP(DCMPLX(0.d0, -KR))
            ENDDO
        ENDDO
    ENDDO
ENDDO

END SUBROUTINE PERIODICFOURIER

SUBROUTINE PERIODICFOURIERPERM(COORDS,NATOMS,NWAVE,NCOEFF,WAVEK,FCOEFF,NPERMGROUP)!,PERMGROUP,NPERMSIZE,NPERMGROUP)
! Calculates Fourier coefficients of the different permutations of a structure.

IMPLICIT NONE

INTEGER, INTENT(IN) :: NPERMGROUP
INTEGER, INTENT(IN) :: NATOMS, NWAVE, NCOEFF
!INTEGER, INTENT(IN) :: PERMGROUP(NATOMS), NPERMSIZE(NPERMGROUP)
DOUBLE PRECISION, INTENT(IN) :: COORDS(NATOMS*3),  WAVEK(3,2*NWAVE+1,2*NWAVE+1,2*NWAVE+1)
!DOUBLE PRECISION, INTENT(IN) :: BOXLX,BOXLY,BOXLZ
COMPLEX*16, INTENT(OUT) :: FCOEFF(NCOEFF,NCOEFF,NCOEFF,NPERMGROUP)

COMPLEX*16 FCOEFFDUMMY(NCOEFF,NCOEFF,NCOEFF)
DOUBLE PRECISION PDUMMY(3*NATOMS)
INTEGER NDUMMY, J1, J2, PATOMS

NDUMMY=1

DO J1=1,NPERMGROUP
    PATOMS=NPERMSIZE(J1)
    DO J2=1,PATOMS
        PDUMMY(3*(J2-1)+1)=COORDS(3*(PERMGROUP(NDUMMY+J2-1)-1)+1)
        PDUMMY(3*(J2-1)+2)=COORDS(3*(PERMGROUP(NDUMMY+J2-1)-1)+2)
        PDUMMY(3*(J2-1)+3)=COORDS(3*(PERMGROUP(NDUMMY+J2-1)-1)+3)
    ENDDO
    CALL PERIODICFOURIER(PATOMS, NWAVE, NCOEFF, PDUMMY, WAVEK, FCOEFFDUMMY)
    FCOEFF(:,:,:,J1) = FCOEFFDUMMY
    NDUMMY=NDUMMY+NPERMSIZE(J1)
ENDDO

END SUBROUTINE PERIODICFOURIERPERM

!SUBROUTINE CALCFOURIERCOEFFS(NATOMS,COORDSA,COORDSB,NWAVE,WAVEK,KWIDTH,FCOEFF)
!
!IMPLICIT NONE
!
!INTEGER, INTENT(IN) :: NATOMS, NWAVE!, NPERMGROUP
!DOUBLE PRECISION, INTENT(IN) :: KWIDTH
!DOUBLE PRECISION, INTENT(IN) :: COORDSA(3*NATOMS), COORDSB(3*NATOMS)
!DOUBLE PRECISION, INTENT(IN) :: WAVEK(3, 2*NWAVE+1,2*NWAVE+1,2*NWAVE+1)
!
!COMPLEX*16 , INTENT(OUT) :: FCOEFF(NFSPACE,NFSPACE,NFSPACE)
!
!COMPLEX*16 FCOEFFA(NFSPACE,NFSPACE,NFSPACE,NPERMGROUP), FCOEFFB(NFSPACE,NFSPACE,NFSPACE,NPERMGROUP), COEFF
!COMPLEX*16 FSPACECMPLX(NFSPACE,NFSPACE,NFSPACE)
!
!INTEGER I, JX, JY, JZ
!DOUBLE PRECISION K2
!
!CALL PERIODICFOURIERPERM(COORDSA,NATOMS,NWAVE,NFSPACE,WAVEK,FCOEFFA,NPERMGROUP)!,PERMGROUP,NPERMSIZE,NPERMGROUP)
!CALL PERIODICFOURIERPERM(COORDSB,NATOMS,NWAVE,NFSPACE,WAVEK,FCOEFFB,NPERMGROUP)!,PERMGROUP,NPERMSIZE,NPERMGROUP)
!
!FCOEFF = DCMPLX(0.D0, 0.D0)
!FCOEFFB = CONJG(FCOEFFB)
!
!DO JX=1,2*NWAVE+1
!    DO JY=1,2*NWAVE+1
!        DO JZ=1,2*NWAVE+1
!            COEFF = DCMPLX(0.D0, 0.D0)
!            K2 = -(WAVEK(1,JX,JY,JZ)**2 + WAVEK(2,JX,JY,JZ)**2 + WAVEK(3,JX,JY,JZ)**2)*KWIDTH**2
!            COEFF = SUM(FCOEFFA(JX,JY,JZ,:)*FCOEFFB(JX,JY,JZ,:))*EXP(K2)
!            FCOEFF(JX,JY,JZ) = COEFF
!        ENDDO
!    ENDDO
!ENDDO
!
!END SUBROUTINE CALCFOURIERCOEFFS

SUBROUTINE CALCFSPACE(NATOMS,COORDSA,COORDSB,NWAVE,WAVEK,KWIDTH,NFSPACE,FSPACE)!,NPERMGROUP)
!
! Calculate FASTOVERLAP real space array
! Given two bulk structures calculates the value of the overlap integral as
! FSPACE(NFSPACE, NFSPACE, NFSPACE). It does this by performing an FFT of the 
! product Fourier coefficients of both structures.
!
USE FASTOVERLAPUTILS, ONLY: FFT3D

IMPLICIT NONE

INTEGER, INTENT(IN) :: NATOMS, NWAVE, NFSPACE!, NPERMGROUP
DOUBLE PRECISION, INTENT(IN) :: KWIDTH
DOUBLE PRECISION, INTENT(IN) :: COORDSA(3*NATOMS), COORDSB(3*NATOMS)
DOUBLE PRECISION, INTENT(IN) :: WAVEK(3, 2*NWAVE+1,2*NWAVE+1,2*NWAVE+1)

DOUBLE PRECISION, INTENT(OUT) :: FSPACE(NFSPACE, NFSPACE, NFSPACE)

COMPLEX*16 FCOEFFA(NFSPACE,NFSPACE,NFSPACE,NPERMGROUP), FCOEFFB(NFSPACE,NFSPACE,NFSPACE,NPERMGROUP), COEFF
COMPLEX*16 FCOEFF(NFSPACE,NFSPACE,NFSPACE)
COMPLEX*16 FSPACECMPLX(NFSPACE,NFSPACE,NFSPACE)

INTEGER I, JX, JY, JZ
DOUBLE PRECISION K2

CALL PERIODICFOURIERPERM(COORDSA,NATOMS,NWAVE,NFSPACE,WAVEK,FCOEFFA,NPERMGROUP)!,PERMGROUP,NPERMSIZE,NPERMGROUP)
CALL PERIODICFOURIERPERM(COORDSB,NATOMS,NWAVE,NFSPACE,WAVEK,FCOEFFB,NPERMGROUP)!,PERMGROUP,NPERMSIZE,NPERMGROUP)

FCOEFF = DCMPLX(0.D0, 0.D0)
FCOEFFB = CONJG(FCOEFFB)

DO JX=1,2*NWAVE+1
    DO JY=1,2*NWAVE+1
        DO JZ=1,2*NWAVE+1
            COEFF = DCMPLX(0.D0, 0.D0)
            K2 = -(WAVEK(1,JX,JY,JZ)**2 + WAVEK(2,JX,JY,JZ)**2 + WAVEK(3,JX,JY,JZ)**2)*KWIDTH**2
            COEFF = SUM(FCOEFFA(JX,JY,JZ,:)*FCOEFFB(JX,JY,JZ,:))*EXP(K2)
            FCOEFF(JX,JY,JZ) = COEFF
        ENDDO
    ENDDO
ENDDO

!Set average overlap to 0
FCOEFF(NWAVE+1,NWAVE+1,NWAVE+1)=(0.d0,0.d0)

CALL FFT3D(NFSPACE,NFSPACE,NFSPACE,FCOEFF,FSPACECMPLX)

FSPACE = ABS(FSPACECMPLX)

END SUBROUTINE CALCFSPACE

SUBROUTINE FINDDISPS(NATOMS,COORDSA,COORDSB,NWAVE,WAVEK,KWIDTH,NFSPACE,DISPS,NDISPS,DEBUG)
! 
! Performs FASTOVERLAP alignment for periodic 3D structures
!
! Calculates up to NDISPS possible displacements to align coordinates COORDSA and COORDSB
! Outputs DISPS as fractional coordinates, so DISPS must be multiplied by the lattice vector
! to obtain the full displacements
!
USE FASTOVERLAPUTILS, ONLY: FINDPEAKS
IMPLICIT NONE
INTEGER, INTENT(IN) :: NATOMS, NWAVE, NFSPACE
INTEGER, INTENT(INOUT) :: NDISPS
LOGICAL, INTENT(IN) :: DEBUG
DOUBLE PRECISION, INTENT(IN) :: KWIDTH, COORDSA(3*NATOMS), COORDSB(3*NATOMS), WAVEK(3, 2*NWAVE+1,2*NWAVE+1,2*NWAVE+1)
DOUBLE PRECISION, INTENT(OUT) :: DISPS(NDISPS,3)

INTEGER J
DOUBLE PRECISION FSPACE(NFSPACE, NFSPACE, NFSPACE), AMPLITUDES(NDISPS)

CALL CALCFSPACE(NATOMS,COORDSA,COORDSB,NWAVE,WAVEK,KWIDTH,NFSPACE,FSPACE)!,NPERMGROUP)

CALL FINDPEAKS(FSPACE, DISPS, AMPLITUDES, NDISPS, DEBUG)

DISPS = DISPS - 1.D0
DO J=1,NDISPS
    DISPS(J,:) = DISPS(J,:)/(/NFSPACE,NFSPACE,NFSPACE/)
ENDDO

END SUBROUTINE FINDDISPS

SUBROUTINE SETBULK()

USE COMMONS, ONLY : MYUNIT,NFREEZE,GEOMDIFFTOL,ORBITTOL,FREEZE,PULLT,TWOD,  &
    &   EFIELDT,AMBERT,QCIAMBERT,AMBER12T,CHRMMT,STOCKT,CSMT,PERMDIST,      &
    &   LOCALPERMDIST,LPERMDIST,OHCELLT,QCIPERMCHECK,PERMOPT,PERMINVOPT,    &
    &   NOINVERSION,GTHOMSONT,MKTRAPT,MULLERBROWNT,RIGID,OHCELLT

IMPLICIT NONE

MYUNIT = 6
NFREEZE = 0
GEOMDIFFTOL = 0.5D0
ORBITTOL = 1.0D-3

FREEZE = .FALSE.
PULLT = .FALSE.
TWOD = .FALSE.
EFIELDT = .FALSE.
AMBERT = .FALSE.
QCIAMBERT = .FALSE.
AMBER12T = .FALSE.
CHRMMT = .FALSE.
STOCKT = .FALSE.
CSMT = .FALSE.
PERMDIST = .TRUE.
LOCALPERMDIST = .FALSE.
LPERMDIST = .FALSE.
QCIPERMCHECK = .FALSE.
PERMOPT = .TRUE.
PERMINVOPT = .FALSE.
NOINVERSION = .FALSE.
GTHOMSONT = .FALSE.
MKTRAPT = .FALSE.
MULLERBROWNT = .FALSE.
RIGID = .FALSE.
OHCELLT = .FALSE.

END SUBROUTINE SETBULK

SUBROUTINE CHECKKEYWORDS()

USE COMMONS, ONLY : MYUNIT,NFREEZE,GEOMDIFFTOL,ORBITTOL,FREEZE,PULLT,TWOD,  &
    &   EFIELDT,AMBERT,QCIAMBERT,AMBER12T,CHRMMT,STOCKT,CSMT,PERMDIST,      &
    &   LOCALPERMDIST,LPERMDIST,OHCELLT,QCIPERMCHECK,PERMOPT,PERMINVOPT,    &
    &   NOINVERSION,GTHOMSONT,MKTRAPT,MULLERBROWNT,RIGID,OHCELLT

IMPLICIT NONE

IF(PERMINVOPT) THEN
    WRITE(*,'(A)') 'ERROR - bulk fastoverlap not compatible with PERMINVOPT keyword'
    WRITE(*,'(A)') 'use keyword OHCELL to use octahedral symmetries'
    STOP
ENDIF

IF(STOCKT) THEN
    WRITE(*,'(A)') 'ERROR - fastoverlap not compatible with STOCK keyword'
    STOP
ENDIF

IF(CSMT) THEN
    WRITE(*,'(A)') 'ERROR - fastoverlap not compatible with CSM keyword'
    STOP
ENDIF

IF(PULLT) THEN
    WRITE(*,'(A)') 'ERROR - fastoverlap not compatible with PULL keyword'
    STOP
ENDIF

IF(EFIELDT) THEN
    WRITE(*,'(A)') 'ERROR - fastoverlap not compatible with EFIELD keyword'
    STOP
ENDIF

IF(RIGID) THEN
    WRITE(*,'(A)') 'ERROR - fastoverlap not compatible with RIGID keyword'
    STOP
ENDIF

IF(QCIPERMCHECK) THEN
    WRITE(*,'(A)') 'ERROR - fastoverlap not compatible with QCIPERMCHECK keyword'
    STOP
ENDIF

IF(QCIAMBERT) THEN
    WRITE(*,'(A)') 'ERROR - fastoverlap not compatible with QCIAMBER keyword'
    STOP
ENDIF

IF(GTHOMSONT) THEN
    WRITE(*,'(A)') 'ERROR - fastoverlap not compatible with GTHOMSON keyword'
    STOP
ENDIF

IF(MKTRAPT) THEN
    WRITE(*,'(A)') 'ERROR - fastoverlap not compatible with MKTRAP keyword'
    STOP
ENDIF

END SUBROUTINE CHECKKEYWORDS

SUBROUTINE ALIGN(COORDSB,COORDSA,NATOMS,DEBUG,BOXLX,BOXLY,BOXLZ,KERNELWIDTH,NDISPLACEMENTS,DISTANCE,DIST2)
! COORDSA becomes the optimal alignment of the optimal permutation of COORDSB

USE FASTOVERLAPUTILS, ONLY: FASTLEN
IMPLICIT NONE

INTEGER, INTENT(IN) :: NATOMS, NDISPLACEMENTS
LOGICAL, INTENT(IN) :: DEBUG
DOUBLE PRECISION, INTENT(IN) :: BOXLX, BOXLY, BOXLZ, KERNELWIDTH
DOUBLE PRECISION, INTENT(INOUT) :: COORDSA(3*NATOMS), COORDSB(3*NATOMS)
DOUBLE PRECISION, INTENT(OUT) :: DISTANCE, DIST2


DOUBLE PRECISION KWIDTH, MAXWAVEK
INTEGER NWAVE, NFSPACE, NDISPS

! Set KWIDTH to be 1/3 of the average interatomic separation
IF (KERNELWIDTH.LE.0.D0) THEN
    KWIDTH = (BOXLX*BOXLY*BOXLZ/NATOMS)**(1.D0/3.D0) / 3.D0
    IF (DEBUG) WRITE(MYUNIT,'(A,G20.10)') 'fastoverlap> kernel distance automatically set to ', KWIDTH
ELSE
    KWIDTH = KERNELWIDTH
    IF (DEBUG) WRITE(MYUNIT,'(A,G20.10)') 'fastoverlap> kernel distance set to ', KWIDTH
ENDIF

! Calculate number of wavevectors that we need to preserve reasonable level of accuracy
MAXWAVEK = 1.5 / KWIDTH
NWAVE = CEILING(2*3.14159265359/MIN(BOXLX,BOXLY,BOXLZ)*MAXWAVEK, 4)
IF (DEBUG) WRITE(MYUNIT,'(A,G20.10)') 'fastoverlap> max wavevector magnitude set to ', MAXWAVEK

! Setting size of Fourier Transform array to be fast
! This also increases the resolution of the method
IF((2*NWAVE+1).LE.200) THEN
    NFSPACE = FASTLEN(4*NWAVE+3)
ELSE
    ! PROBABLY NOT THE BEST WAY TO CALCULATE THIS!
    NFSPACE = 2**CEILING(LOG(4.D0*NWAVE+3.D0)/LOG(2.D0),4)
ENDIF
IF (DEBUG) WRITE(MYUNIT,'(A,I4)') 'fastoverlap> overlap array resolution set to ', NFSPACE


IF(NDISPLACEMENTS.EQ.0) THEN
    NDISPS = 10
ELSE
    NDISPS = NDISPLACEMENTS
END IF
IF (DEBUG) WRITE(MYUNIT,'(A,I3)') 'fastoverlap> number of displacements to be tested = ', NDISPS

!WRITE(*,*) "DEBUG,BOXLX,BOXLY,BOXLZ,KWIDTH,DISTANCE,DIST2,NDISPLACEMENTS,NWAVE,NFSPACE"
!WRITE(*,*) DEBUG,BOXLX,BOXLY,BOXLZ,KWIDTH,DISTANCE,DIST2,NDISPS,NWAVE,NFSPACE
CALL ALIGN1(COORDSB,COORDSA,NATOMS,DEBUG,BOXLX,BOXLY,BOXLZ,KWIDTH,DISTANCE,DIST2,NDISPS,NWAVE,NFSPACE)

END SUBROUTINE ALIGN

SUBROUTINE ALIGN1(COORDSB,COORDSA,NATOMS,DEBUG,BOXLX,BOXLY,BOXLZ,KWIDTH,DISTANCE,DIST2,NDISPLACEMENTS,NWAVE,NFSPACE)

USE COMMONS, ONLY: OHCELLT

IMPLICIT NONE

INTEGER, INTENT(IN) :: NATOMS, NDISPLACEMENTS, NFSPACE, NWAVE
LOGICAL, INTENT(IN) :: DEBUG
DOUBLE PRECISION, INTENT(IN) :: BOXLX, BOXLY, BOXLZ, KWIDTH
DOUBLE PRECISION, INTENT(INOUT) :: COORDSA(3*NATOMS), COORDSB(3*NATOMS)
DOUBLE PRECISION, INTENT(OUT) :: DISTANCE, DIST2

DOUBLE PRECISION WAVEK(3, 2*NWAVE+1,2*NWAVE+1,2*NWAVE+1), K2, DISTSAVE
DOUBLE PRECISION SAVEA(3*NATOMS), SAVEB(3*NATOMS)
COMPLEX*16 FCOEFFS(NFSPACE,NFSPACE,NFSPACE), FCOEFFA(NFSPACE,NFSPACE,NFSPACE,NPERMGROUP), &
 & FCOEFFB(NFSPACE,NFSPACE,NFSPACE,NPERMGROUP), FCOEFFDUMMYA(NFSPACE,NFSPACE,NFSPACE,NPERMGROUP)
INTEGER J, JX, JY, JZ, OPNUM, NDISPS, JXL, JYL, JZL, JXH, JYH, JZH, JXI, JYI, JZI

CALL CHECKKEYWORDS()
OHCELLTSAVE = OHCELLT
OHCELLT = .FALSE.

! Calculating Fourier Coefficients of COORDSA and COORDSB
CALL SETWAVEK(NWAVE,WAVEK,BOXLX,BOXLY,BOXLZ)
CALL PERIODICFOURIERPERM(COORDSA,NATOMS,NWAVE,NFSPACE,WAVEK,FCOEFFA,NPERMGROUP)
CALL PERIODICFOURIERPERM(COORDSB,NATOMS,NWAVE,NFSPACE,WAVEK,FCOEFFB,NPERMGROUP)

FCOEFFS = DCMPLX(0.D0, 0.D0)
FCOEFFB = CONJG(FCOEFFB)

! Calculating Fourier Coefficients of overlap integral
DO JZ=1,2*NWAVE+1
    DO JY=1,2*NWAVE+1
        DO JX=1,2*NWAVE+1
            K2 = EXP(-0.5D0 * (WAVEK(1,JX,JY,JZ)**2 + WAVEK(2,JX,JY,JZ)**2 + WAVEK(3,JX,JY,JZ)**2)*KWIDTH**2)
            FCOEFFA(JX,JY,JZ,:) = FCOEFFA(JX,JY,JZ,:) * K2
            FCOEFFB(JX,JY,JZ,:) = FCOEFFB(JX,JY,JZ,:) * K2
            FCOEFFS(JX,JY,JZ) = SUM(FCOEFFA(JX,JY,JZ,:)*FCOEFFB(JX,JY,JZ,:))
        ENDDO
    ENDDO
ENDDO

!Set average overlap to 0
FCOEFFS(NWAVE+1,NWAVE+1,NWAVE+1)=(0.D0,0.D0)

SAVEB(1:3*NATOMS) = COORDSB(1:3*NATOMS)

IF (OHCELLTSAVE) THEN
    DISTSAVE = HUGE(DISTSAVE)
    DO OPNUM=1,48
        IF (DEBUG) WRITE(MYUNIT,'(A,I2)') 'fastoverlap> Trying Oh symmetry operation number ',OPNUM
        CALL OHOPS(COORDSA,SAVEA,OPNUM,NATOMS)
    
        ! Applying octahedral symmetry operation to FCOEFFA
        JZL=0; JZH=2*NWAVE+1; JZI=1
        IF(OHOPSMAT(3,3,OPNUM).EQ.(-1.D0))  JZH=0; JZL=2*NWAVE+1; JZI=-1
        JYL=0; JYH=2*NWAVE+1; JYI=1
        IF(OHOPSMAT(2,2,OPNUM).EQ.(-1.D0))  JYH=0; JYL=2*NWAVE+1; JYI=-1
        JXL=0; JXH=2*NWAVE+1; JXI=1
        IF(OHOPSMAT(1,1,OPNUM).EQ.(-1.D0))  JXH=0; JXL=2*NWAVE+1; JXI=-1
        ! Reflecting axis is equivalent to reversing Fourier Coefficients
        FCOEFFDUMMYA(1:2*NWAVE+1,1:2*NWAVE+1,1:2*NWAVE+1,:) = &
 & FCOEFFA(JXL:JXH:JXI,JXL:JXH:JXI,JXL:JXH:JXI,:)
        
        ! Recalculating Fourier Coefficients
        FCOEFFS = DCMPLX(0.D0, 0.D0)
        DO J=1,NPERMGROUP
            DO JZ=1,2*NWAVE+1
                DO JY=1,2*NWAVE+1
                    DO JX=1,2*NWAVE+1
                        FCOEFFS(JX,JY,JZ) = FCOEFFS(JX,JY,JZ) + &
                        & FCOEFFDUMMYA(JX,JY,JZ,J)*FCOEFFB(JX,JY,JZ,J)
                    ENDDO
                ENDDO
            ENDDO
        ENDDO
        FCOEFFS(NWAVE+1,NWAVE+1,NWAVE+1)=(0.D0,0.D0)

        NDISPS = NDISPLACEMENTS
        CALL ALIGNCOEFFS(SAVEB,SAVEA,NATOMS,DEBUG,FCOEFFS,NFSPACE,BOXLX,BOXLY,BOXLZ,DISTANCE,DIST2,NDISPS)

        IF (DISTANCE.LT.DISTSAVE) THEN
            IF (DEBUG) WRITE(MYUNIT,'(A,I2,A,G20.10)') &
 & 'fastoverlap> Oh symmetry operation ', OPNUM, ' found better alignment, distance=', distance
            XBESTASAVE(1:3*NATOMS) = SAVEA(1:3*NATOMS)
            DISTSAVE = DISTANCE
        ELSE
            IF (DEBUG) WRITE(MYUNIT,'(A,G20.10)') &
 & 'fastoverlap> overall best alignment distance=', distsave
        ENDIF

    ENDDO
ELSE
    IF (DEBUG) WRITE(MYUNIT,'(A)') 'fastoverlap> not testing Oh symmetry'

    XBESTASAVE(1:3*NATOMS) = COORDSA(1:3*NATOMS)
    NDISPS = NDISPLACEMENTS
    CALL ALIGNCOEFFS(SAVEB,XBESTASAVE,NATOMS,DEBUG,FCOEFFS,NFSPACE,BOXLX,BOXLY,BOXLZ,DISTSAVE,DIST2,NDISPS)
    
    IF (DEBUG) WRITE(MYUNIT,'(A,G20.10)') &
 & 'fastoverlap> overall best alignment distance=', distsave
ENDIF


DISTANCE = DISTSAVE
DIST2 = DISTANCE**2
COORDSA(1:3*NATOMS) = XBESTASAVE(1:3*NATOMS)

OHCELLT = OHCELLTSAVE

END SUBROUTINE ALIGN1

SUBROUTINE ALIGNCOEFFS(COORDSB,COORDSA,NATOMS,DEBUG,FCOEFFS,NFSPACE,BOXLX,BOXLY,BOXLZ,DISTANCE,DIST2,NDISPS)

USE FASTOVERLAPUTILS, ONLY : FFT3D, FINDPEAKS
IMPLICIT NONE

INTEGER, INTENT(INOUT) :: NDISPS
INTEGER, INTENT(IN) :: NATOMS, NFSPACE
LOGICAL, INTENT(IN) :: DEBUG
COMPLEX*16, INTENT(IN) ::  FCOEFFS(NFSPACE,NFSPACE,NFSPACE)
DOUBLE PRECISION, INTENT(IN) :: BOXLX, BOXLY, BOXLZ
DOUBLE PRECISION, INTENT(INOUT) :: COORDSA(3*NATOMS), COORDSB(3*NATOMS)
DOUBLE PRECISION, INTENT(OUT) :: DISTANCE, DIST2

COMPLEX*16 FSPACECMPLX(NFSPACE,NFSPACE,NFSPACE)
DOUBLE PRECISION FSPACE(NFSPACE,NFSPACE,NFSPACE), DISPS(NDISPS,3), R(3,3), BESTDIST
DOUBLE PRECISION AMPLITUDES(NDISPS)
INTEGER J, J1

CALL FFT3D(NFSPACE,NFSPACE,NFSPACE,FCOEFFS,FSPACECMPLX)
FSPACE = ABS(FSPACECMPLX)

CALL FINDPEAKS(FSPACE, DISPS, AMPLITUDES, NDISPS, DEBUG)
IF (DEBUG) WRITE(MYUNIT,'(A,I3,A)') 'fastoverlap> found ', NDISPS, ' candidate displacements'

DISPS = DISPS - 1.D0
DISPS(:,1) = DISPS(:,1)*BOXLX/NFSPACE
DISPS(:,2) = DISPS(:,2)*BOXLY/NFSPACE
DISPS(:,3) = DISPS(:,3)*BOXLZ/NFSPACE

BESTDIST = HUGE(BESTDIST)
DUMMYB(1:3*NATOMS) = COORDSB(1:3*NATOMS)
DO J=1,NDISPS
    IF (DEBUG) WRITE(MYUNIT,'(A,I3)') 'fastoverlap> testing displacement', J
    DO J1=1,NATOMS
        DUMMYA(J1*3-2:J1*3) = COORDSA(J1*3-2:J1*3) - DISPS(J,:)
    ENDDO
    CALL MINPERMDIST(DUMMYB,DUMMYA,NATOMS,DEBUG,BOXLX,BOXLY,BOXLZ,.TRUE.,.FALSE.,DISTANCE,DIST2,.FALSE.,R)
    IF (DISTANCE.LT.BESTDIST) THEN
        BESTDIST = DISTANCE
        IF (DEBUG) WRITE(MYUNIT,'(A,G20.10)') 'fastoverlap> found new best alignment distance=', BESTDIST
        XBESTA(1:3*NATOMS) = DUMMYA(1:3*NATOMS)
    ELSE
        IF (DEBUG) WRITE(MYUNIT,'(A,G20.10)') 'fastoverlap> best aligment distance found=', BESTDIST
    ENDIF
ENDDO

IF (DEBUG) WRITE(MYUNIT,'(A,G20.10)') 'fastoverlap> FINAL best aligment distance found=', BESTDIST


COORDSA(1:3*NATOMS) = XBESTA(1:3*NATOMS)
DISTANCE = BESTDIST
DIST2 = BESTDIST**2

END SUBROUTINE ALIGNCOEFFS

SUBROUTINE ALIGN2(COORDSB,COORDSA,NATOMS,DEBUG,BOXLX,BOXLY,BOXLZ,TWOD,DISTANCE,DIST2,RIGID,DISPBEST,NDISPS,BESTPERM,DISP)

! COORDSA becomes the optimal alignment of the optimal permutation of COORDSB
! DISTANCE returns 
! TWOD, RIGID aren't currently implemented
! DEBUG doesn't do anything either
!USE COMMONS, ONLY : PERMGROUP, NPERMSIZE, NPERMGROUP
USE FASTOVERLAPUTILS, ONLY: FASTLEN
IMPLICIT NONE

INTEGER, INTENT(IN) :: NATOMS, NDISPS
! These currently aren't used, but are included to match call signature of minpermdist
LOGICAL, INTENT(IN) :: DEBUG, TWOD, RIGID
DOUBLE PRECISION, INTENT(IN) :: BOXLX, BOXLY, BOXLZ
DOUBLE PRECISION, INTENT(INOUT) :: COORDSA(3*NATOMS), COORDSB(3*NATOMS)
DOUBLE PRECISION, INTENT(OUT) :: DISTANCE, DIST2, DISPBEST(3), DISP(3, NATOMS)
INTEGER, INTENT(OUT) :: BESTPERM(NATOMS)

DOUBLE PRECISION, ALLOCATABLE :: WAVEK(:,:,:,:)
DOUBLE PRECISION DISPS(NDISPS, 3), KERNELWIDTH, MAXWAVEK, BOX(3)
INTEGER NWAVE, NFSPACE, FOUNDDISPS, J, J1, J2, IND1, IND2

DOUBLE PRECISION PDUMMYA(3*NATOMS), PDUMMYB(3*NATOMS), DUMMYA(3*NATOMS), DUMMYB(3*NATOMS),& 
    DUMMY(3*NATOMS), LDISTANCE, WORSTRAD, CURRDIST, MDISP(3), DISP1D(NATOMS)
INTEGER SAVEPERM(NATOMS), NDUMMY, PATOMS

DOUBLE PRECISION PERMDIST

BOX = (/BOXLX, BOXLY, BOXLZ/)

! Calculate kernel width automatically if not specified
IF (KWIDTH.EQ.0.D0) THEN
    KERNELWIDTH = (BOXLX*BOXLY*BOXLZ/NATOMS)**(1.D0/3.D0) / 3.D0
ELSE
    KERNELWIDTH = KWIDTH
ENDIF

! Number of wavevectors that we need to preserve reasonable level of accuracy
MAXWAVEK = 1.5 / KERNELWIDTH
NWAVE = CEILING(2*3.14159265359/MINVAL(BOX)*MAXWAVEK, 4)
ALLOCATE(WAVEK(3,2*NWAVE+1,2*NWAVE+1,2*NWAVE+1))
CALL SETWAVEK(NWAVE,WAVEK,BOXLX,BOXLY,BOXLZ)

! Setting size of Fourier Transform array to be fast
! This also increases the resolution of the method
IF((2*NWAVE+1).LE.200) THEN
    NFSPACE = FASTLEN(4*NWAVE+3)
ELSE
    ! PROBABLY NOT THE BEST WAY TO CALCULATE THIS!
    NFSPACE = 2**CEILING(LOG(4.D0*NWAVE+3.D0)/LOG(2.D0),4)
ENDIF

FOUNDDISPS = NDISPS
! FASTOVERLAP alignment
CALL FINDDISPS(NATOMS,COORDSB,COORDSA,NWAVE,WAVEK,KERNELWIDTH,NFSPACE,DISPS,FOUNDDISPS,DEBUG)


! Perform permutational alignment for each displacement, keep the best
DISTANCE = HUGE(DISTANCE)
DUMMYB = COORDSB
DO J=1,FOUNDDISPS
    DISPS(J,:) = DISPS(J,:)*BOX
    
    DO J1=1,NATOMS
        DUMMYA(3*J1-2:3*J1) = COORDSA(3*J1-2:3*J1) - DISPS(J,:)
    ENDDO
    CALL FINDBESTPERMUTATION(NATOMS, DUMMYB, DUMMYA, BOXLX, BOXLY, BOXLZ, SAVEPERM, CURRDIST, DIST2, WORSTRAD)
    IF(CURRDIST.LT.DISTANCE) THEN
        DISTANCE = CURRDIST
        NDUMMY=0
        DISPBEST = DISPS(J,:)
        BESTPERM=SAVEPERM
    ENDIF
ENDDO

! Find and subtract median displacement
DO J1=1,NATOMS
    DUMMYA(3*J1-2:3*J1) = COORDSA(3*J1-2:3*J1) - DISPBEST
ENDDO

CALL GETDISPLACEMENT(DISP, NATOMS, DUMMYB, DUMMYA, BESTPERM, BOX)   

DO J=1,3
    DISP1D = DISP(J,:)
    CALL MEDIAN(DISP1D, NATOMS, MDISP(J))
ENDDO 
DISPBEST = DISPBEST + MDISP
DO J1=1,NATOMS
    DUMMYA(3*J1-2:3*J1) = COORDSA(3*J1-2:3*J1) - DISPBEST
ENDDO

! Recalculate permutational alignment
CALL FINDBESTPERMUTATION(NATOMS, DUMMYB, DUMMYA, BOXLX, BOXLY, BOXLZ, SAVEPERM, DISTANCE, DIST2, WORSTRAD)

! Find and subtract mean displacement
CALL GETDISPLACEMENT(DISP, NATOMS, DUMMYB, DUMMYA, BESTPERM, BOX)
DO J=1,3
    MDISP(J) = SUM(DISP(J,:))/NATOMS
ENDDO
DISPBEST = DISPBEST - MDISP
DO J1=1,NATOMS
    DUMMYA(3*J1-2:3*J1) = COORDSA(3*J1-2:3*J1) - DISPBEST
ENDDO

CALL GETDISTANCE(DISTANCE, NATOMS, DUMMYB, DUMMYA, BESTPERM, BOX)

DISPBEST = DISPBEST - MDISP
DO J1=1,NATOMS
    COORDSA(3*J1-2:3*J1) = DUMMYA(3*J1-2:3*J1)
ENDDO

CALL GETDISTANCE(DISTANCE, NATOMS, COORDSB, COORDSA, BESTPERM, BOX)

DO J1=1,NATOMS
    SAVEPERM(J1) = J1
    J2 = BESTPERM(J1)
    COORDSA(3*J1-2:3*J1) = DUMMYA(3*J2-2:3*J2)
ENDDO

CALL GETDISTANCE(DISTANCE, NATOMS, COORDSB, COORDSA, SAVEPERM, BOX)

DISTANCE = DISTANCE**0.5

END SUBROUTINE ALIGN2

SUBROUTINE MEDIANMINPERMDIST(COORDSB,COORDSA,NATOMS,DEBUG,BOXLX,BOXLY,BOXLZ,DISTANCE,DIST2,DISPBEST,DISP)

! COORDSA becomes the optimal alignment of the optimal permutation of COORDSB
! DISTANCE returns 
! TWOD, RIGID aren't currently implemented
! DEBUG doesn't do anything either
USE COMMONS, ONLY : BESTPERM
IMPLICIT NONE

INTEGER, INTENT(IN) :: NATOMS
LOGICAL, INTENT(IN) :: DEBUG
DOUBLE PRECISION, INTENT(IN) :: BOXLX, BOXLY, BOXLZ
DOUBLE PRECISION, INTENT(INOUT) :: COORDSA(3*NATOMS), COORDSB(3*NATOMS)
DOUBLE PRECISION, INTENT(OUT) :: DISTANCE, DIST2, DISPBEST(3), DISP(3,NATOMS)

INTEGER J, J1, J2, IND1, IND2, SAVEPERM(NATOMS)

DOUBLE PRECISION PDUMMYA(3*NATOMS), PDUMMYB(3*NATOMS), DUMMYA(3*NATOMS), DUMMYB(3*NATOMS),& 
    DUMMY(3*NATOMS), LDISTANCE, WORSTRAD, CURRDIST, MDISP(3), DISP1D(NATOMS), BOX(3)

DOUBLE PRECISION PERMDIST

DISPBEST = 0.D0
BOX = (/BOXLX, BOXLY, BOXLZ/)

DUMMYA(1:3*NATOMS) = COORDSA(1:3*NATOMS)
DUMMYB(1:3*NATOMS) = COORDSB(1:3*NATOMS)

CALL FINDBESTPERMUTATION(NATOMS, DUMMYB, DUMMYA, BOXLX, BOXLY, BOXLZ, BESTPERM, DISTANCE, DIST2, WORSTRAD)

IF (DEBUG) WRITE(MYUNIT,'(A,G20.10)') 'medianminpermdist> distance after permuting', SQRT(DISTANCE)

CALL GETDISPLACEMENT(DISP, NATOMS, DUMMYB, DUMMYA, BESTPERM, BOX)   

DO J=1,3
    DISP1D = DISP(J,:)
    CALL MEDIAN(DISP1D, NATOMS, MDISP(J))
ENDDO 
IF (DEBUG) WRITE(MYUNIT,'(A,3G20.10)') 'medianminpermdist> median displacement', MDISP
DISPBEST = DISPBEST + MDISP
DO J1=1,NATOMS
    DUMMYA(3*J1-2:3*J1) = COORDSA(3*J1-2:3*J1) - DISPBEST
ENDDO

! Recalculate permutational alignment
CALL FINDBESTPERMUTATION(NATOMS, DUMMYB, DUMMYA, BOXLX, BOXLY, BOXLZ, BESTPERM, DISTANCE, DIST2, WORSTRAD)

IF (DEBUG) WRITE(MYUNIT,'(A,G20.10)') 'medianminpermdist> distance after subtracting median', SQRT(DISTANCE)

! Find and subtract mean displacement
CALL GETDISPLACEMENT(DISP, NATOMS, DUMMYB, DUMMYA, BESTPERM, BOX)
DO J=1,3
    MDISP(J) = SUM(DISP(J,:))/NATOMS
ENDDO
DISPBEST = DISPBEST - MDISP
DO J1=1,NATOMS
    DUMMYA(3*J1-2:3*J1) = COORDSA(3*J1-2:3*J1) - DISPBEST
ENDDO

DO J1=1,NATOMS
    SAVEPERM(J1) = J1
    J2 = BESTPERM(J1)
    COORDSA(3*J1-2:3*J1) = DUMMYA(3*J2-2:3*J2)
ENDDO

CALL GETDISTANCE(DISTANCE, NATOMS, COORDSB, COORDSA, SAVEPERM, BOX)

DISTANCE = DISTANCE**0.5

IF (DEBUG) WRITE(MYUNIT,'(A,G20.10)') 'medianminpermdist> final distance', DISTANCE

END SUBROUTINE MEDIANMINPERMDIST

SUBROUTINE FINDBESTPERMUTATION(NATOMS, COORDSB, COORDSA, BOXLX, BOXLY, BOXLZ, SAVEPERM, LDISTANCE, DIST2, WORSTRAD)

! Find best permutational alignment of bulk structures COORDSB with COORDSA given
! PERMGROUP, NPERMSIZE specified as module variables. LDISTANCE returns the calculated
! distance^2 between the structures

IMPLICIT NONE

INTEGER, INTENT(IN) :: NATOMS
DOUBLE PRECISION, INTENT(IN) :: COORDSA(3*NATOMS), COORDSB(3*NATOMS), BOXLX, BOXLY, BOXLZ
INTEGER, INTENT(OUT) :: SAVEPERM(NATOMS)
DOUBLE PRECISION, INTENT(OUT) :: LDISTANCE, DIST2, WORSTRAD

DOUBLE PRECISION PDUMMYA(3*NATOMS), PDUMMYB(3*NATOMS), DUMMYA(3*NATOMS), DUMMYB(3*NATOMS), CURRDIST
INTEGER NEWPERM(NATOMS), NDUMMY, J, J1, J2, J3, IND1, IND2
INTEGER PATOMS, LPERM(NATOMS)


NDUMMY=1
DO J1=1,NATOMS
    NEWPERM(J1)=J1
ENDDO

CURRDIST = 0.D0
DO J1=1,NPERMGROUP
    PATOMS=INT(NPERMSIZE(J1),4)
    DO J2=1,PATOMS
        IND2 = NEWPERM(PERMGROUP(NDUMMY+J2-1))
        PDUMMYA(3*J2-2:3*J2)=COORDSA(3*IND2-2:3*IND2)
        PDUMMYB(3*J2-2:3*J2)=COORDSB(3*IND2-2:3*IND2)
    ENDDO
    CALL MINPERM(PATOMS, PDUMMYB, PDUMMYA, BOXLX, BOXLY, BOXLZ, .TRUE., LPERM, LDISTANCE, DIST2, WORSTRAD)
    CURRDIST = CURRDIST + LDISTANCE    
    SAVEPERM(1:NATOMS)=NEWPERM(1:NATOMS)
    DO J2=1,INT(PATOMS,4)
        SAVEPERM(PERMGROUP(NDUMMY+J2-1))=NEWPERM(PERMGROUP(NDUMMY+INT(LPERM(J2),4)-1))
    ENDDO

    IF (NSETS(J1).GT.0) THEN
        DO J2=1,PATOMS
            DO J3=1,NSETS(J1)
                SAVEPERM(SETS(PERMGROUP(NDUMMY+J2-1),J3))=SETS(NEWPERM(PERMGROUP(NDUMMY+LPERM(J2)-1)),J3)
            ENDDO
        ENDDO
    ENDIF

    NDUMMY=NDUMMY+NPERMSIZE(J1)
    NEWPERM(1:NATOMS)=SAVEPERM(1:NATOMS)
ENDDO

LDISTANCE = CURRDIST

END SUBROUTINE FINDBESTPERMUTATION

SUBROUTINE INITIALISE(NEWNATOMS, NEWPERMGROUP, NEWNPERMSIZE)

! (Re)allocates arrays that define allowed permuations
IMPLICIT NONE

INTEGER, INTENT(IN) :: NEWNATOMS, NEWPERMGROUP(:), NEWNPERMSIZE(:)


IF(.NOT.SIZE(PERMGROUP).EQ.SIZE(NEWPERMGROUP)) THEN
    IF(ALLOCATED(PERMGROUP)) THEN
        DEALLOCATE(PERMGROUP)
    ENDIF
    ALLOCATE(PERMGROUP(SIZE(NEWPERMGROUP)))
ENDIF

NPERMGROUP = SIZE(NEWNPERMSIZE)
IF(.NOT.SIZE(NPERMSIZE).EQ.SIZE(NEWNPERMSIZE)) THEN
    IF(ALLOCATED(NPERMSIZE)) THEN
        DEALLOCATE(NPERMSIZE)
    ENDIF
    ALLOCATE(NPERMSIZE(NPERMGROUP))
ENDIF

NATOMS = NEWNATOMS
PERMGROUP = NEWPERMGROUP
NPERMSIZE = NEWNPERMSIZE

END SUBROUTINE INITIALISE

SUBROUTINE GETDISTANCE(DIST, NATOMS, COORDSB, COORDSA, PERMLIST, BOX)

! Calculates distance between two bulk structures given a permutation 
! specified by PERMLIST
!USE COMMONS, ONLY : PERMGROUP, NPERMSIZE, NPERMGROUP
IMPLICIT NONE

INTEGER, INTENT(IN) ::NATOMS
DOUBLE PRECISION, INTENT(IN) :: COORDSA(3*NATOMS), COORDSB(3*NATOMS), BOX(3)
INTEGER, INTENT(IN) :: PERMLIST(NATOMS)
DOUBLE PRECISION, INTENT(OUT) :: DIST

DOUBLE PRECISION PERMDIST
INTEGER J1, J2, PATOMS, NDUMMY, IND1, IND2

DIST = 0.D0
NDUMMY=0

DO J1=1,NPERMGROUP
    PATOMS=NPERMSIZE(J1)
    DO J2=1,PATOMS
        IND1 = J2+NDUMMY
        IND2 = PERMLIST(J2+NDUMMY)
        DIST = DIST + PERMDIST(COORDSB(3*IND1-2),COORDSA(3*IND2-2),BOX,.TRUE.)
    ENDDO
    NDUMMY = NDUMMY+PATOMS
ENDDO

END SUBROUTINE GETDISTANCE

SUBROUTINE GETDISPLACEMENT(DISP, NATOMS, COORDSB, COORDSA, PERMLIST, BOX)

! Calculates minimum displacement between atoms in two bulk structures given a 
! permutation specified by PERMLIST
!USE COMMONS, ONLY : PERMGROUP, NPERMSIZE, NPERMGROUP
IMPLICIT NONE

INTEGER, INTENT(IN) :: NATOMS
DOUBLE PRECISION, INTENT(IN) :: COORDSA(3*NATOMS), COORDSB(3*NATOMS), BOX(3)
INTEGER, INTENT(IN) :: PERMLIST(NATOMS)
DOUBLE PRECISION, INTENT(OUT) :: DISP(3, NATOMS)

DOUBLE PRECISION :: D(3)
INTEGER J1, J2, PATOMS, NDUMMY, IND1, IND2

NDUMMY=0
DO J1=1,NPERMGROUP
    PATOMS=NPERMSIZE(J1)
    DO J2=1,PATOMS
        IND1 = J2+NDUMMY
        IND2 = PERMLIST(J2+NDUMMY)
        D = COORDSB(3*IND1-2:3*IND1) - COORDSA(3*IND2-2:3*IND2)
        D = D - BOX*ANINT(D/BOX)
        DISP(:,IND1) = D
    ENDDO
    NDUMMY = NDUMMY+PATOMS
ENDDO

END SUBROUTINE GETDISPLACEMENT

END MODULE BULKFASTOVERLAP


INCLUDE "bulkmindist.f90"
INCLUDE "minpermdist.f90"
INCLUDE "minperm.f90"
INCLUDE "newmindist.f90"
INCLUDE "orient.f90"